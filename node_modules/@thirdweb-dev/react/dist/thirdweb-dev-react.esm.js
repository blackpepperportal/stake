import { ChainId, NATIVE_TOKENS, getProviderForNetwork, ThirdwebSDK, CONTRACTS_MAP, ListingType, UserWallet, SUPPORTED_CHAIN_IDS } from '@thirdweb-dev/sdk';
export { ChainId } from '@thirdweb-dev/sdk';
import { ethers, utils, providers, Signer, constants, BigNumber } from 'ethers';
import invariant from 'tiny-invariant';
import { Connector, normalizeChainId, useSigner as useSigner$1, useAccount, useNetwork as useNetwork$1, WagmiProvider, useProvider, useConnect as useConnect$1 } from 'wagmi';
export { defaultChains, defaultL2Chains, useAccount, useProvider } from 'wagmi';
import React, { useMemo, useContext, createContext, useRef, useEffect, useState, useLayoutEffect, useCallback, useId } from 'react';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { QueryClient, QueryClientProvider, useQueryClient, useQuery, useMutation } from '@tanstack/react-query';
import { CoinbaseWalletConnector } from 'wagmi/connectors/coinbaseWallet';
import { InjectedConnector } from 'wagmi/connectors/injected';
import { WalletConnectConnector } from 'wagmi/connectors/walletConnect';
import { detect } from 'detect-browser';
import mime from 'mime/lite.js';
import useDimensions from 'react-cool-dimensions';
import { createPortal } from 'react-dom';
import copy from 'copy-to-clipboard';
import styled from '@emotion/styled';
import { keyframes, ThemeProvider as ThemeProvider$1 } from '@emotion/react';
import color from 'color';
import * as menu from '@zag-js/menu';
import { useMachine, normalizeProps } from '@zag-js/react';
import { FiLock, FiChevronDown, FiCheck, FiCopy, FiWifi, FiShuffle, FiXCircle } from 'react-icons/fi';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

const CHAIN_ID_TO_GNOSIS_SERVER_URL = {
  [ChainId.Mainnet]: "https://safe-transaction.mainnet.gnosis.io",
  [ChainId.Avalanche]: "https://safe-transaction.avalanche.gnosis.io",
  [ChainId.Polygon]: "https://safe-transaction.polygon.gnosis.io",
  [ChainId.Goerli]: "https://safe-transaction.goerli.gnosis.io",
  [ChainId.Rinkeby]: "https://safe-transaction.rinkeby.gnosis.io"
};

const __IS_SERVER__$1 = typeof window === "undefined";

class GnosisSafeConnector extends Connector {
  // config
  constructor(config) {
    var _config$chains;

    // filter out any chains that gnosis doesnt support before passing to connector
    config.chains = (_config$chains = config.chains) === null || _config$chains === void 0 ? void 0 : _config$chains.filter(c => c.id in CHAIN_ID_TO_GNOSIS_SERVER_URL);
    super({ ...config,
      options: undefined
    });

    _defineProperty(this, "id", "gnosis");

    _defineProperty(this, "ready", __IS_SERVER__$1);

    _defineProperty(this, "name", "Gnosis Safe");

    _defineProperty(this, "previousConnector", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "safeSigner", void 0);

    if (!__IS_SERVER__$1) {
      this.ready = true;
    }
  }

  async connect() {
    this.safeSigner = await this.createSafeSigner();
    const account = await this.getAccount();
    const provider = await this.getProvider();
    const id = await this.getChainId();
    return {
      account,
      provider,
      chain: {
        id,
        unsupported: this.isChainUnsupported(id)
      }
    };
  }

  async createSafeSigner() {
    var _this$previousConnect, _this$config, _this$config2;

    const signer = await ((_this$previousConnect = this.previousConnector) === null || _this$previousConnect === void 0 ? void 0 : _this$previousConnect.getSigner());
    const safeAddress = (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.safeAddress;
    const safeChainId = (_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : _this$config2.safeChainId;
    invariant(signer, "cannot create Gnosis Safe signer without a personal signer");
    const signerChainId = await signer.getChainId();
    invariant(signerChainId === safeChainId, "chainId of personal signer has to match safe chainId");
    invariant(safeAddress, "safeConfig.safeAddress is required, did you forget to call setSafeConfig?");
    invariant(safeChainId, "safeConfig.safeChainId is required, did you forget to call setSafeConfig?");
    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];
    invariant(serverUrl, "Chain not supported");
    const [safeEthersAdapters, safeCoreSdk, safeEthersLib] = await Promise.all([import('@gnosis.pm/safe-ethers-adapters'), import('@gnosis.pm/safe-core-sdk'), import('@gnosis.pm/safe-ethers-lib')]);
    const ethAdapter = new safeEthersLib.default({
      ethers,
      signer
    });
    const safe = await safeCoreSdk.default.create({
      ethAdapter: ethAdapter,
      safeAddress
    });
    const service = new safeEthersAdapters.SafeService(serverUrl);
    return new safeEthersAdapters.SafeEthersSigner(safe, service, signer.provider);
  }

  async disconnect() {
    this.config = undefined;
    this.safeSigner = undefined;
    this.previousConnector = undefined;
    return undefined;
  }

  async getAccount() {
    const signer = await this.getSigner();
    return await signer.getAddress();
  }

  async getChainId() {
    return (await this.getSigner()).getChainId();
  }

  async getProvider() {
    return (await this.getSigner()).provider;
  }

  async getSigner() {
    if (!this.safeSigner) {
      this.safeSigner = await this.createSafeSigner();
    }

    return this.safeSigner;
  }

  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }

  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      this.emit("change", {
        account: utils.getAddress(accounts[0])
      });
    }
  }

  isChainUnsupported(chainId) {
    var _this$config3;

    return (_this$config3 = this.config) !== null && _this$config3 !== void 0 && _this$config3.safeChainId ? chainId === this.config.safeChainId : false;
  }

  onChainChanged(chainId) {
    const id = normalizeChainId(chainId);
    const unsupported = this.isChainUnsupported(id);
    this.emit("change", {
      chain: {
        id,
        unsupported
      }
    });
  }

  onDisconnect() {
    this.emit("disconnect");
  }

  setConfiguration(connector, config) {
    this.previousConnector = connector;
    this.config = config;
  }

}

const __IS_SERVER__ = typeof window === "undefined";

const LOCAL_STORAGE_KEY = "--magic-link:configuration";
class MagicConnector extends Connector {
  getConfiguration() {
    if (__IS_SERVER__) {
      return undefined;
    }

    const config = window.localStorage.getItem(LOCAL_STORAGE_KEY);

    if (config) {
      this.configuration = JSON.parse(config);
    }

    return this.configuration;
  }

  constructor(config) {
    super({ ...config,
      options: config === null || config === void 0 ? void 0 : config.options
    });

    _defineProperty(this, "id", "magic");

    _defineProperty(this, "name", "Magic");

    _defineProperty(this, "ready", __IS_SERVER__);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "configuration", void 0);

    _defineProperty(this, "magic", void 0);

    this.options = config.options;

    if (!__IS_SERVER__) {
      this.ready = true;

      if (this.options.doNotAutoConnect || !this.getConfiguration()) {
        return;
      }

      this.connect(true);
    }
  }

  async connect(isAutoConnect) {
    const {
      apiKey,
      doNotAutoConnect,
      rpcUrls,
      ...options
    } = this.options;
    const configuration = this.getConfiguration();

    try {
      invariant(configuration, "did you forget to set the configuration via: setConfiguration()?");

      if (isAutoConnect) {
        configuration.showUI = false;
      }

      return import('magic-sdk').then(async m => {
        this.magic = new m.Magic(apiKey, options);
        await this.magic.auth.loginWithMagicLink(configuration);
        const provider = this.getProvider();

        if (provider.on) {
          provider.on("accountsChanged", this.onAccountsChanged);
          provider.on("chainChanged", this.onChainChanged);
          provider.on("disconnect", this.onDisconnect);
        }

        const account = await this.getAccount();
        const id = await this.getChainId();
        return {
          account,
          provider,
          chain: {
            id,
            unsupported: this.isChainUnsupported(id)
          }
        };
      });
    } catch (e) {
      if (!isAutoConnect) {
        throw e;
      }

      return {
        account: undefined,
        provider: undefined,
        chain: undefined
      };
    }
  }

  async disconnect() {
    const provider = this.getProvider();

    if (provider !== null && provider !== void 0 && provider.removeListener) {
      provider.removeListener("accountsChanged", this.onAccountsChanged);
      provider.removeListener("chainChanged", this.onChainChanged);
      provider.removeListener("disconnect", this.onDisconnect);
    }

    this.setConfiguration(undefined);
  }

  async switchChain(chainId) {
    invariant(!this.isChainUnsupported(chainId), "chain is not supported");
    const provider = this.getProvider();

    if (provider !== null && provider !== void 0 && provider.removeListener) {
      provider.removeListener("accountsChanged", this.onAccountsChanged);
      provider.removeListener("chainChanged", this.onChainChanged);
      provider.removeListener("disconnect", this.onDisconnect);
    }

    this.options.network = {
      chainId,
      rpcUrl: this.options.rpcUrls[chainId]
    };
    await this.connect();
    this.onChainChanged(chainId);
    return this.chains.find(c => c.id === chainId);
  }

  async getAccount() {
    const signer = await this.getSigner();
    return await signer.getAddress();
  }

  async getChainId() {
    const signer = await this.getSigner();
    return await signer.getChainId();
  }

  getProvider() {
    invariant(this.magic, "connector is not initialized");
    return new providers.Web3Provider(this.magic.rpcProvider);
  }

  async getSigner() {
    if (!this.magic) {
      await this.connect();
    }

    return this.getProvider().getSigner();
  }

  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }

  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      this.emit("change", {
        account: utils.getAddress(accounts[0])
      });
    }
  }

  isChainUnsupported(chainId) {
    return !this.chains.some(x => x.id === chainId);
  }

  onChainChanged(chainId) {
    const id = normalizeChainId(chainId);
    const unsupported = this.isChainUnsupported(id);
    this.emit("change", {
      chain: {
        id,
        unsupported
      }
    });
  }

  onDisconnect() {
    this.emit("disconnect");
  }

  setConfiguration(configuration) {
    if (configuration) {
      this.configuration = configuration;
      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(configuration));
    } else {
      this.configuration = undefined;
      window.localStorage.removeItem(LOCAL_STORAGE_KEY);
    }
  }

}

const chain = {
  mainnet: {
    id: ChainId.Mainnet,
    name: "Ethereum Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.Mainnet],
    rpcUrls: ["https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://etherscan.io"
    }]
  },
  rinkeby: {
    id: ChainId.Rinkeby,
    name: "Rinkeby",
    nativeCurrency: NATIVE_TOKENS[ChainId.Rinkeby],
    rpcUrls: ["https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://rinkeby.etherscan.io"
    }],
    testnet: true
  },
  goerli: {
    id: ChainId.Goerli,
    name: "Goerli",
    nativeCurrency: NATIVE_TOKENS[ChainId.Goerli],
    rpcUrls: ["https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }],
    testnet: true
  },
  polygonMainnet: {
    id: ChainId.Polygon,
    name: "Polygon Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.Polygon],
    rpcUrls: ["https://polygon-rpc.com", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://rpc-mainnet.matic.quiknode.pro", "https://matic-mainnet-full-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "Polygonscan",
      url: "https://polygonscan.com"
    }]
  },
  polygonTestnetMumbai: {
    id: ChainId.Mumbai,
    name: "Mumbai",
    nativeCurrency: NATIVE_TOKENS[ChainId.Mumbai],
    rpcUrls: ["https://matic-mumbai.chainstacklabs.com", "https://rpc-mumbai.maticvigil.com", "https://matic-testnet-archive-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    }],
    testnet: true
  },
  avalanche: {
    id: ChainId.Avalanche,
    name: "Avalanche",
    nativeCurrency: NATIVE_TOKENS[ChainId.Avalanche],
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc", "https://rpc.ankr.com/avalanche"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://snowtrace.io/"
    }],
    testnet: false
  },
  avalancheFujiTestnet: {
    id: ChainId.AvalancheFujiTestnet,
    name: "Avalanche Fuji Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.AvalancheFujiTestnet],
    rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io/"
    }],
    testnet: true
  },
  fantom: {
    id: ChainId.Fantom,
    name: "Fantom Opera",
    nativeCurrency: NATIVE_TOKENS[ChainId.Fantom],
    rpcUrls: ["https://rpc.ftm.tools"],
    blockExplorers: [{
      name: "FTMscan",
      url: "https://ftmscan.com/"
    }],
    testnet: false
  },
  fantomTestnet: {
    id: ChainId.FantomTestnet,
    name: "Fantom Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.FantomTestnet],
    rpcUrls: ["https://rpc.testnet.fantom.network"],
    blockExplorers: [{
      name: "FTMscan",
      url: "https://testnet.ftmscan.com/"
    }],
    testnet: true
  },
  optimism: {
    id: ChainId.Optimism,
    name: "Optimism",
    nativeCurrency: NATIVE_TOKENS[ChainId.Optimism],
    rpcUrls: ["https://mainnet.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://optimistic.etherscan.io/"
    }],
    testnet: false
  },
  optimismTestnet: {
    id: ChainId.OptimismTestnet,
    name: "Optimism Kovan",
    nativeCurrency: NATIVE_TOKENS[ChainId.OptimismTestnet],
    rpcUrls: ["https://kovan.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://kovan-optimistic.etherscan.io/"
    }],
    testnet: true
  },
  arbitrum: {
    id: ChainId.Arbitrum,
    name: "Arbitrum One",
    nativeCurrency: NATIVE_TOKENS[ChainId.Arbitrum],
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbiscan",
      url: "https://arbiscan.io/"
    }],
    testnet: false
  },
  arbitrumTestnet: {
    id: ChainId.ArbitrumTestnet,
    name: "Arbitrum Rinkeby",
    nativeCurrency: NATIVE_TOKENS[ChainId.ArbitrumTestnet],
    rpcUrls: ["https://rinkeby.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbiscan",
      url: "https://testnet.arbiscan.io/"
    }],
    testnet: true
  },
  binanceSmartChainMainnet: {
    id: ChainId.BinanceSmartChainMainnet,
    name: "Binance Smart Chain Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.BinanceSmartChainMainnet],
    rpcUrls: ["https://bsc-dataseed1.binance.org"],
    blockExplorers: [{
      name: "BscScan",
      url: "https://bscscan.com/"
    }],
    testnet: false
  },
  binanceSmartChainTestnet: {
    id: ChainId.BinanceSmartChainTestnet,
    name: "Binance Smart Chain Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.BinanceSmartChainTestnet],
    rpcUrls: ["https://data-seed-prebsc-1-s1.binance.org:8545"],
    blockExplorers: [{
      name: "BscScan",
      url: "https://testnet.bscscan.com/"
    }],
    testnet: true
  }
};
const defaultSupportedChains = Object.values(chain);
function getChainFromChainId(chainId) {
  return defaultSupportedChains.find(c => c.id === chainId);
}

const ThirdwebAuthConfigContext = /*#__PURE__*/createContext(undefined);
const ThirdwebAuthConfigProvider = _ref => {
  let {
    value,
    children
  } = _ref;
  // Remove trailing slash from URL if present
  const authConfig = useMemo(() => value ? { ...value,
    authUrl: value.authUrl.replace(/\/$/, "")
  } : undefined, [value]);
  return /*#__PURE__*/jsx(ThirdwebAuthConfigContext.Provider, {
    value: authConfig,
    children: children
  });
};
function useThirdwebAuthConfig() {
  return useContext(ThirdwebAuthConfigContext);
}

const defaultChainRpc = {
  [ChainId.Mainnet]: "mainnet",
  [ChainId.Rinkeby]: "rinkeby",
  [ChainId.Goerli]: "goerli",
  [ChainId.Polygon]: "polygon",
  [ChainId.Mumbai]: "mumbai",
  [ChainId.Fantom]: "fantom",
  [ChainId.Avalanche]: "avalanche"
};
const ThirdwebConfigContext = /*#__PURE__*/createContext({
  rpcUrlMap: defaultChainRpc,
  supportedChains: defaultSupportedChains
});
const ThirdwebConfigProvider = _ref => {
  let {
    value,
    children
  } = _ref;
  return /*#__PURE__*/jsx(ThirdwebConfigContext.Provider, {
    value: value,
    children: children
  });
};
function useThirdwebConfigContext() {
  return useContext(ThirdwebConfigContext);
}

/**
 *
 * @internal
 */

function useSigner() {
  var _account$data, _network$data$chain, _account$data2, _network$data, _network$data$chain2;

  const [signer, getSigner] = useSigner$1();
  const [account] = useAccount();
  const [network] = useNetwork$1();

  const _getSignerPromise = useRef(null);

  const address = (_account$data = account.data) === null || _account$data === void 0 ? void 0 : _account$data.address;
  const chainId = (_network$data$chain = network.data.chain) === null || _network$data$chain === void 0 ? void 0 : _network$data$chain.id;
  const previousAddress = usePrevious((_account$data2 = account.data) === null || _account$data2 === void 0 ? void 0 : _account$data2.address);
  const previousChainId = usePrevious((_network$data = network.data) === null || _network$data === void 0 ? void 0 : (_network$data$chain2 = _network$data.chain) === null || _network$data$chain2 === void 0 ? void 0 : _network$data$chain2.id);
  useEffect(() => {
    if (address !== previousAddress || chainId !== previousChainId) {
      if (!_getSignerPromise.current) {
        return;
      } else {
        _getSignerPromise.current = getSigner().finally(() => {
          _getSignerPromise.current = null;
        });
      }
    }
  }, [address, chainId, previousAddress, previousChainId]);
  return Signer.isSigner(signer.data) ? signer.data : undefined;
}

function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  const ref = useRef(); // Store current value in ref

  useEffect(() => {
    ref.current = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref.current;
}

// SDK handles this under the hood for us
const defaultdAppMeta = {
  name: "thirdweb powered dApp"
};
const defaultWalletConnectors = ["metamask", "walletConnect", "walletLink"];
/**
 *
 * The `<ThirdwebProvider />` component lets you control what networks you want users to connect to, what types of wallets can connect to your app, and the settings for the [Typescript SDK](https://docs.thirdweb.com/typescript).
 *
 * @example
 * You can wrap your application with the provider as follows:
 *
 * ```jsx title="App.jsx"
 * import { ThirdwebProvider, ChainId } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   return (
 *     <ThirdwebProvider desiredChainId={ChainId.Mainnet}>
 *       <YourApp />
 *     </ThirdwebProvider>
 *   );
 * };
 * ```
 *
 * @public
 *
 */

const ThirdwebProvider = _ref => {
  let {
    sdkOptions,
    chainRpc = defaultChainRpc,
    supportedChains = defaultSupportedChains.map(c => c.id),
    walletConnectors = defaultWalletConnectors,
    dAppMeta = defaultdAppMeta,
    desiredChainId,
    authConfig,
    storageInterface,
    queryClient,
    autoConnect = true,
    children
  } = _ref;

  // construct the wagmi options
  const _supporrtedChains = useMemo(() => {
    return supportedChains.map(c => {
      if (typeof c === "number") {
        return defaultSupportedChains.find(sc => sc.id === c);
      }

      return c;
    }).filter(c => c !== undefined);
  }, [supportedChains]);

  const _rpcUrlMap = useMemo(() => {
    return _supporrtedChains.reduce((prev, curr) => {
      prev[curr.id] = curr.id in chainRpc ? getProviderForNetwork(chainRpc[curr.id] || curr.rpcUrls[0]) : curr.rpcUrls[0];
      return prev;
    }, {});
  }, [chainRpc, _supporrtedChains]);

  const wagmiProps = useMemo(() => {
    const walletConnectClientMeta = {
      name: dAppMeta.name,
      url: dAppMeta.url || "",
      icons: [dAppMeta.logoUrl || ""],
      description: dAppMeta.description || ""
    };
    const walletLinkClientMeta = {
      appName: dAppMeta.name,
      appLogoUrl: dAppMeta.logoUrl,
      darkMode: dAppMeta.isDarkMode
    };
    return {
      autoConnect,
      connectorStorageKey: "tw:provider:connectors",
      connectors: _ref2 => {
        let {
          chainId
        } = _ref2;
        return walletConnectors.map(connector => {
          // injected connector
          if (typeof connector === "string" && (connector === "injected" || connector === "metamask") || typeof connector === "object" && (connector.name === "injected" || connector.name === "metamask")) {
            return new InjectedConnector({
              options: typeof connector === "string" ? {
                shimDisconnect: true,
                shimChainChangedDisconnect: true
              } : connector.options,
              chains: _supporrtedChains
            });
          }

          if (typeof connector === "string" && connector === "walletConnect" || typeof connector === "object" && connector.name === "walletConnect") {
            return new WalletConnectConnector({
              options: typeof connector === "string" ? {
                chainId,
                rpc: _rpcUrlMap,
                clientMeta: walletConnectClientMeta,
                qrcode: true
              } : {
                chainId,
                rpc: _rpcUrlMap,
                clientMeta: walletConnectClientMeta,
                qrcode: true,
                ...connector.options
              },
              chains: _supporrtedChains
            });
          }

          if (typeof connector === "string" && (connector === "coinbase" || connector === "walletLink") || typeof connector === "object" && (connector.name === "coinbase" || connector.name === "walletLink")) {
            const jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];
            return new CoinbaseWalletConnector({
              chains: _supporrtedChains,
              options: typeof connector === "string" ? { ...walletLinkClientMeta,
                jsonRpcUrl
              } : { ...walletLinkClientMeta,
                jsonRpcUrl,
                ...connector.options
              }
            });
          }

          if (typeof connector === "object" && connector.name === "magic") {
            const jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];
            return new MagicConnector({
              chains: _supporrtedChains,
              options: { ...connector.options,
                network: {
                  rpcUrl: jsonRpcUrl,
                  chainId: desiredChainId || 1
                },
                rpcUrls: _rpcUrlMap
              }
            });
          }

          if (typeof connector === "string" && connector === "gnosis" || typeof connector === "object" && connector.name === "gnosis") {
            return new GnosisSafeConnector({
              chains: _supporrtedChains
            });
          }

          return null;
        }).filter(c => c !== null);
      }
    };
  }, [dAppMeta.name, dAppMeta.url, dAppMeta.logoUrl, dAppMeta.description, dAppMeta.isDarkMode, autoConnect, walletConnectors, _supporrtedChains, _rpcUrlMap, desiredChainId]);
  const readonlySettings = useMemo(() => {
    var _sdkOptions$readonlyS, _sdkOptions$readonlyS2;

    if (sdkOptions !== null && sdkOptions !== void 0 && (_sdkOptions$readonlyS = sdkOptions.readonlySettings) !== null && _sdkOptions$readonlyS !== void 0 && _sdkOptions$readonlyS.rpcUrl && sdkOptions !== null && sdkOptions !== void 0 && (_sdkOptions$readonlyS2 = sdkOptions.readonlySettings) !== null && _sdkOptions$readonlyS2 !== void 0 && _sdkOptions$readonlyS2.chainId) {
      return sdkOptions.readonlySettings;
    }

    if (!desiredChainId) {
      return undefined;
    }

    let rpcUrl = _rpcUrlMap[desiredChainId];

    try {
      rpcUrl = getProviderForNetwork(rpcUrl);
    } catch (e) {
      console.error("failed to configure rpc url for chain: \"".concat(desiredChainId, "\". Did you forget to pass \"desiredChainId\" to the <ThirdwebProvider /> component?")); // cannot set readonly without a valid rpc url

      return undefined;
    }

    return {
      chainId: desiredChainId,
      rpcUrl
    };
  }, [_rpcUrlMap, desiredChainId, sdkOptions === null || sdkOptions === void 0 ? void 0 : sdkOptions.readonlySettings]);
  const sdkOptionsWithDefaults = useMemo(() => {
    const opts = sdkOptions;
    return { ...opts,
      readonlySettings
    };
  }, [sdkOptions, readonlySettings]);
  return /*#__PURE__*/jsx(ThirdwebConfigProvider, {
    value: {
      rpcUrlMap: _rpcUrlMap,
      supportedChains: _supporrtedChains
    },
    children: /*#__PURE__*/jsx(WagmiProvider, { ...wagmiProps,
      children: /*#__PURE__*/jsx(ThirdwebSDKProviderWagmiWrapper, {
        queryClient: queryClient,
        desiredChainId: desiredChainId,
        sdkOptions: sdkOptionsWithDefaults,
        storageInterface: storageInterface,
        authConfig: authConfig,
        children: children
      })
    })
  });
};

const ThirdwebSDKProviderWagmiWrapper = _ref3 => {
  let {
    children,
    ...props
  } = _ref3;
  const provider = useProvider();
  const signer = useSigner();
  return /*#__PURE__*/jsx(ThirdwebSDKProvider, {
    signer: signer,
    provider: provider,
    ...props,
    children: children
  });
};

const ThirdwebSDKContext = /*#__PURE__*/createContext({
  desiredChainId: -1
});

/**
 * A barebones wrapper around the Thirdweb SDK.
 *
 * You can use this in order to be able to pass a provider & signer directly to the SDK.
 *
 * @remarks Utilizing this provider will mean hooks for wallet management are not available, if you need those please use the {@link ThirdwebProvider} instead.
 *
 * @beta
 */
const ThirdwebSDKProvider = _ref4 => {
  let {
    sdkOptions,
    desiredChainId,
    storageInterface,
    provider,
    signer,
    queryClient,
    authConfig,
    children
  } = _ref4;
  const queryClientWithDefault = useMemo(() => {
    return queryClient ? queryClient : new QueryClient();
  }, [queryClient]);
  const sdk = useMemo(() => {
    if (!desiredChainId || typeof window === "undefined") {
      return undefined;
    }

    const _sdk = new ThirdwebSDK(provider, sdkOptions, storageInterface);

    _sdk._chainId = desiredChainId;
    return _sdk;
  }, [provider, sdkOptions, storageInterface, desiredChainId]);
  useEffect(() => {
    if (signer && sdk && sdk._chainId === desiredChainId) {
      sdk.updateSignerOrProvider(signer);
    }
  }, [signer, sdk, desiredChainId]);
  const ctxValue = useMemo(() => ({
    sdk,
    desiredChainId: desiredChainId || -1,
    _inProvider: true
  }), [desiredChainId, sdk]);
  return /*#__PURE__*/jsx(ThirdwebAuthConfigProvider, {
    value: authConfig,
    children: /*#__PURE__*/jsx(QueryClientProvider, {
      client: queryClientWithDefault,
      children: /*#__PURE__*/jsx(ThirdwebSDKContext.Provider, {
        value: ctxValue,
        children: children
      })
    })
  });
};
/**
 * @internal
 */

function useSDKContext() {
  const ctx = React.useContext(ThirdwebSDKContext);
  invariant(ctx._inProvider, "useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?");
  return ctx;
}
/**
 *
 * @returns {@link ThirdwebSDK}
 * Access the instance of the thirdweb SDK created by the ThirdwebProvider
 * to call methods using the connected wallet on the desiredChainId.
 * @example
 * ```javascript
 * const sdk = useSDK();
 * ```
 */


function useSDK() {
  const {
    sdk
  } = useSDKContext();
  return sdk;
}
/**
 * @internal
 */

function useDesiredChainId() {
  const {
    desiredChainId
  } = useSDKContext();
  return desiredChainId;
}
/**
 * @internal
 */

function useActiveChainId() {
  const sdk = useSDK();
  return sdk === null || sdk === void 0 ? void 0 : sdk._chainId;
}

const TW_CACHE_KEY_PREFIX = "tw-cache";
/**
 * @internal
 */

function createCachekey(input) {
  if (input[0] === TW_CACHE_KEY_PREFIX) {
    return input;
  }

  return [TW_CACHE_KEY_PREFIX, ...input];
}
/**
 * @internal
 */


function createContractCacheKey() {
  let contractAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : constants.AddressZero;
  let input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return createCachekey(["contract", contractAddress, ...input]);
}
/**
 @internal
 */

function createCacheKeyWithNetwork(input, chainId) {
  return cacheKeys.network.active(chainId).concat(input);
}
/**
 * @internal
 */

function invalidateContractAndBalances(queryClient, contractAddress, chainId) {
  return Promise.all([queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), chainId)), queryClient.invalidateQueries(createCacheKeyWithNetwork(createCachekey(["balance"]), chainId))]);
}
/**
 @internal
 */

const cacheKeys = {
  auth: {
    user: () => createCachekey(["user"])
  },
  network: {
    active: chainId => createCachekey(["chainId", chainId])
  },
  wallet: {
    balance: (chainId, walletAddress, tokenAddress) => createCacheKeyWithNetwork(createCachekey(["balance", {
      walletAddress,
      tokenAddress
    }]), chainId)
  },
  contract: {
    type: contractAddress => createContractCacheKey(contractAddress, ["contract-type"]),
    compilerMetadata: contractAddress => createContractCacheKey(contractAddress, ["publish-metadata"]),
    typeAndCompilerMetadata: contractAddress => createContractCacheKey(contractAddress, ["contract-type-and-metadata"]),
    metadata: contractAddress => createContractCacheKey(contractAddress, ["metadata"]),
    extractFunctions: contractAddress => createContractCacheKey(contractAddress, ["extractFunctions"]),
    call: (contractAddress, functionName, args) => createContractCacheKey(contractAddress, ["call", functionName, args]),
    events: {
      getEvents: (contractAddress, eventName) => createContractCacheKey(contractAddress, ["events", "getEvents", {
        eventName
      }]),
      getAllEvents: contractAddress => createContractCacheKey(contractAddress, ["events", "getAllEvents"])
    },
    // specific contract types
    nft: {
      get: (contractAddress, tokenId) => createContractCacheKey(contractAddress, ["get", {
        tokenId
      }]),
      balanceOf: (contractAddress, owner, tokenId) => createContractCacheKey(contractAddress, ["balanceOf", {
        owner,
        tokenId
      }]),
      query: {
        all: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["query", "all", params] : ["query", "all"]),
        totalCirculatingSupply: contractAddress => createContractCacheKey(contractAddress, ["query", "totalCirculatingSupply"]),
        totalCount: contractAddress => createContractCacheKey(contractAddress, ["query", "totalCount"]),
        owned: {
          all: (contractAddress, owner) => createContractCacheKey(contractAddress, ["query", "owned", "all", owner])
        }
      },
      drop: {
        getAllUnclaimed: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllUnclaimed", params] : ["getAllUnclaimed"]),
        totalUnclaimedSupply: contractAddress => createContractCacheKey(contractAddress, ["totalUnclaimedSupply"]),
        totalClaimedSupply: contractAddress => createContractCacheKey(contractAddress, ["totalClaimedSupply"]),
        revealer: {
          getBatchesToReveal: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getBatchesToReveal", params] : ["getBatchesToReveal"])
        }
      }
    },
    token: {
      totalSupply: contractAddress => createContractCacheKey(contractAddress, ["totalSupply"]),
      balanceOf: (contractAddress, walletAddress) => createContractCacheKey(contractAddress, ["balanceOf", {
        walletAddress
      }])
    },
    marketplace: {
      getListing: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["getListing", {
        listingId
      }]),
      getAllListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllListings", params] : ["getAllListings"]),
      getActiveListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getActiveListings", params] : ["getActiveListings"]),
      getBidBufferBps: contractAddress => createContractCacheKey(contractAddress, ["getBidBufferBps"]),
      auction: {
        getWinningBid: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinningBid", {
          listingId
        }]),
        getWinner: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinner", {
          listingId
        }])
      }
    }
  },
  // extensions
  extensions: {
    claimConditions: {
      getActive: (contractAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getActive", {
        tokenId
      }] : ["claimConditions", "getActive"]),
      getAll: (contractAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getAll", {
        tokenId
      }] : ["claimConditions", "getAll"]),
      getClaimIneligibilityReasons: (contractAddress, params, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getIneligibilityReasons", {
        tokenId
      }, params] : ["claimConditions", "getIneligibilityReasons", params])
    },
    // primary sale contracts
    sales: {
      getRecipient: contractAddress => createContractCacheKey(contractAddress, ["sales"])
    },
    // royalties
    royalties: {
      getDefaultRoyaltyInfo: contractAddress => createContractCacheKey(contractAddress, ["royalties"])
    },
    // platform fees
    platformFees: {
      get: contractAddress => createContractCacheKey(contractAddress, ["platformFees"])
    },
    // contract metadata
    metadata: {
      get: contractAddress => createContractCacheKey(contractAddress, ["metadata"])
    },
    roles: {
      getAll: contractAddress => createContractCacheKey(contractAddress, ["roles"]),
      get: (contractAddress, role) => createContractCacheKey(contractAddress, ["roles", {
        role
      }])
    }
  }
};

/**
 * Hook to securely login to a backend with the connected wallet. The backend
 * authentication URL must be configured on the ThirdwebProvider.
 *
 * @param config - Configuration for the login.
 * @returns - A function to invoke to login with the connected wallet.
 *
 * @beta
 */
function useLogin(config) {
  const sdk = useSDK();
  const queryClient = useQueryClient();
  const authConfig = useThirdwebAuthConfig();
  React.useEffect(() => {
    const queryParams = new URLSearchParams(window.location.search);
    const error = queryParams.get("error");

    if (error && config !== null && config !== void 0 && config.onError) {
      // If there is an error, parse it and trigger the onError callback
      config.onError(decodeURI(error));
    }
  }, [config]);

  async function login(cfg) {
    invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    const payload = await (sdk === null || sdk === void 0 ? void 0 : sdk.auth.login(authConfig.domain, cfg));
    const encodedPayload = encodeURIComponent(btoa(JSON.stringify(payload)));
    const encodedRedirectTo = encodeURIComponent((config === null || config === void 0 ? void 0 : config.redirectTo) || authConfig.loginRedirect || window.location.toString());
    queryClient.invalidateQueries(cacheKeys.auth.user()); // Redirect to the login URL with the encoded payload

    window.location.href = "".concat(authConfig.authUrl, "/login?payload=").concat(encodedPayload, "&redirect=").concat(encodedRedirectTo);
  }

  return login;
}

/**
 * Hook to logout the connected wallet from the backend.
 * The backend logout URL must be configured on the ThirdwebProvider.
 *
 * @returns - A function to invoke to logout.
 *
 * @beta
 */

function useLogout() {
  const queryClient = useQueryClient();
  const authConfig = useThirdwebAuthConfig();

  function logout() {
    invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    queryClient.invalidateQueries(cacheKeys.auth.user());
    window.location.href = "".concat(authConfig.authUrl, "/logout");
  }

  return logout;
}

/**
 * Hook to get the currently logged in user.
 *
 * @returns - The currently logged in user or null if not logged in, as well as a loading state.
 *
 * @beta
 */
function useUser() {
  const authConfig = useThirdwebAuthConfig();
  const {
    data: user,
    isLoading
  } = useQuery(cacheKeys.auth.user(), async () => {
    invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    const res = await fetch("".concat(authConfig.authUrl, "/user"));
    return await res.json();
  });
  return {
    user,
    isLoading
  };
}

/**
 *
 * @returns
 * @internal
 */

function useAuth(loginConfig) {
  const user = useUser();
  const login = useLogin(loginConfig);
  const logout = useLogout();
  return { ...user,
    login,
    logout
  };
}

/**
 * @internal
 * @param contractType - the contract type
 * @param contractAddress - the contract address
 * @returns the instance of the contract for the given type and address
 */
function useBuiltinContract(contractType, contractAddress) {
  const sdk = useSDK();

  if (!sdk || !contractAddress || !contractType) {
    return undefined;
  }

  return sdk.getBuiltInContract(contractAddress, contractType);
}

/**
 * Hook for getting an instance of an `EditionDrop` contract. This conract is used to interface with ERC1155 compliant NFTs that can be lazily minted.
 * @param contractAddress - the address of the Edition Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useEditionDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const editionDrop = useEditionDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the edition drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(tokenId, quantity) {
 *     await editionDrop.claim(tokenId, quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useEditionDrop(contractAddress) {
  return useBuiltinContract("edition-drop", contractAddress);
}

/**
 * Hook for getting an instance of an `Edition` contract. This contract is used to interface with ERC1155 compliant NFTs.
 * @param contractAddress - the address of the Edition contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useEdition } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const edition = useEdition("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the edition contract in the rest of the component
 *
 *   // For example, this function will return all the NFTs on this contract
 *   async function getNFTs() {
 *     const nfts = await edition.getAll()
 *     return nfts
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useEdition(contractAddress) {
  return useBuiltinContract("edition", contractAddress);
}

/**
 * Hook for getting an instance of an `NFTDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.
 * @param contractAddress - the address of the NFT Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useNFTDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const nftDrop = useNFTDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the nft drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(quantity) {
 *     await nftDrop.claim(quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useNFTDrop(contractAddress) {
  return useBuiltinContract("nft-drop", contractAddress);
}

/**
 * Hook for getting an instance of a `Marketplace` contract. This contract is used to support marketplace for purchase and sale of on-chain assets.
 * @param contractAddress - the address of the Marketplace contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useMarketplace } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const marketplace = useMarketplace("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the marketplace contract in the rest of the component
 *
 *   // For example, this function will return all the listings on the marketplace
 *   async function getListings() {
 *     const listings = await marketplace.getAll()
 *     return listings
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useMarketplace(contractAddress) {
  return useBuiltinContract("marketplace", contractAddress);
}

/**
 * Hook for getting an instance of an `NFTCollection` contract. This contract is meant to interface with ERC721 compliant NFTs.
 * @param contractAddress - the address of the NFT Collection contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useNFTCollection } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const nftCollection = useNFTCollection("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the nftCollection contract in the rest of the component
 *
 *   // For example, this function will return all the NFTs on this contract
 *   async function getNFTs() {
 *     const nfts = await nftCollection.getAll()
 *     return nfts
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useNFTCollection(contractAddress) {
  return useBuiltinContract("nft-collection", contractAddress);
}

/**
 * Hook for getting an instance of a `Pack` contract. This contract supports the creation of on-chain luck-based lootboxes.
 * @param contractAddress - the address of the Pack contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { usePack } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const pack = usePack("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the pack contract in the rest of the component
 *
 *   // For example, this function will get all the packs on this contract
 *   async function getPacks() {
 *     const packs = await pack.getAll()
 *     return packs
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function usePack(contractAddress) {
  return useBuiltinContract("pack", contractAddress);
}

/**
 * Hook for getting an instance of a `Token` contract. This contract supports ERC20 compliant tokens.
 * @param contractAddress - the address of the Token contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useToken } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const token = useToken("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the token contract in the rest of the component
 *
 *   // For example, this function will get the connected wallets token balance
 *   async function balance() {
 *     const balance = await token.balance()
 *     return balance
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useToken(contractAddress) {
  return useBuiltinContract("token", contractAddress);
}

/**
 * Hook for getting an instance of a `Token Drop` contract.
 * @param contractAddress - the address of the Token Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useTokenDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const tokenDrop = useTokenDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the token drop contract in the rest of the component
 *
 *   // For example, this function will get the connected wallets token balance
 *   async function balance() {
 *     const balance = await tokenDrop.balance()
 *     return balance
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useTokenDrop(contractAddress) {
  return useBuiltinContract("token-drop", contractAddress);
}

/**
 * Hook for getting an instance of an `Vote` contract. This contract enables fully featured voting-based decentralized governance systems.
 * @param contractAddress - the address of the Vote contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useVote } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const vote = useVote("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the vote contract in the rest of the component
 *
 *   // For example, this function will get all the proposals on this contract
 *   async function getProposals() {
 *     const proposals = await vote.getAll()
 *     return proposals
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useVote(contractAddress) {
  return useBuiltinContract("vote", contractAddress);
}

/**
 * Hook for getting an instance of a `Split` contract. This contract supports fund distribution to multiple parties.
 * @param contractAddress - the address of the Split contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useSplit } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const split = useSplit("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the split contract in the rest of the component
 *
 *   // For example, this function will retrun all the receipients of the split
 *   async function getRecipients() {
 *     const recipients = await split.getAllRecipients()
 *     return recipients
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useSplit(contractAddress) {
  return useBuiltinContract("split", contractAddress);
}

/**
 * Hook for getting an instance of an `Multiwrap` contract. This contract is an ERC721 in which you can wrap ERC721, ERC1155 and ERC20 tokens.
 * @param contractAddress - the address of the Multiwrap contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useMultiwrap } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const multiwrap = useMultiwrap("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the multiwrap contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet wrap tokens
 *   async function wrap(tokensToWrap, wrappedNFTMetadata) {
 *     await multiwrap.wrap(tokensToWrap, wrappedNFTMetadata)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useMultiwrap(contractAddress) {
  return useBuiltinContract("multiwrap", contractAddress);
}

/**
 * Hook for getting an instance of an `SignatureDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.
 * @param contractAddress - the address of the NFT Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useSignatureDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const signatureDrop = useSignatureDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the Signature drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(quantity) {
 *     await signatureDrop.claim(quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 * @depreated use `useContract()` instead
 */

function useSignatureDrop(contractAddress) {
  return useBuiltinContract("signature-drop", contractAddress);
}

/**
 * for now just re-exported
 * @internal
 */

function useConnect() {
  return useConnect$1();
}

/**
 * Hook for disconnecting the currently connected wallet
 *
 * ```javascript
 * import { useDisconnect } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * The following will enable users to disconnect their wallet from the page.
 * ```javascript
 * import { useDisconnect } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const disconnect = useDisconnect()
 *
 *   return (
 *     <button onClick={disconnect}>
 *       Disconnect
 *     </button>
 *   )
 * }
 * ```
 *
 * Once users disconnect their wallet, the `useAddress`, `useChainId`, `useAccount`, and `useNetwork` hooks will no longer return values until a user connects their wallet again.
 *
 * @public
 */

function useDisconnect(options) {
  const optsWithDefaults = { ...{
      reconnectAfterGnosis: true
    },
    ...options
  };
  const [, connect] = useConnect();
  const [data, disconnect] = useAccount();
  return async () => {
    var _data$data;

    const previousConnector = ((_data$data = data.data) === null || _data$data === void 0 ? void 0 : _data$data.connector) instanceof GnosisSafeConnector && data.data.connector.previousConnector || undefined; // if it's gnosis, just connect the previous connector

    if (optsWithDefaults.reconnectAfterGnosis && previousConnector) {
      try {
        return await connect(previousConnector);
      } catch (err) {
        console.error("failed to re-connect to previous connector", err); // if it fails for whatever reason just disconnect

        return disconnect();
      }
    }

    return disconnect();
  };
}

/**
 * Hook for accessing the address of the connected wallet
 *
 * ```javascript
 * import { useAddress } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * To get the address of the connected wallet, you can use the hook as follows:
 *
 * ```javascript
 * import { useAddress } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const address = useAddress()
 *
 *   return <div>{address}</div>
 * }
 * ```
 *
 * The `address` variable will hold the address of the connected wallet if a user has connected using one of the supported wallet connection hooks.
 *
 * @public
 */

function useAddress() {
  var _account$data;

  const [account] = useAccount();
  return (_account$data = account.data) === null || _account$data === void 0 ? void 0 : _account$data.address;
}

/**
 * @internal
 */

function useReadonlySDK(readonlyRpcUrl, sdkOptions, storageInterface) {
  return useMemo(() => {
    return new ThirdwebSDK(readonlyRpcUrl, { ...sdkOptions,
      readonlySettings: { ...(sdkOptions === null || sdkOptions === void 0 ? void 0 : sdkOptions.readonlySettings),
        rpcUrl: readonlyRpcUrl
      }
    }, storageInterface);
  }, [readonlyRpcUrl, sdkOptions]);
}

function detectEnv(userAgent) {
  return detect(userAgent);
}
/**
 * @internal
 */


function isAndroid() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("android") : false;
}
/**
 * @internal
 */

function isIOS() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
/**
 * @internal
 */

function detectOS() {
  const env = detectEnv();
  return env !== null && env !== void 0 && env.os ? env.os : undefined;
}
/**
 * @internal
 */


function isMobile() {
  const os = detectOS();
  return os ? isAndroid() || isIOS() : false;
}

/**
 * Hook for connecting to a Metamask wallet.
 *
 * ```javascript
 * import { useMetamask } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * We can allow users to connect their metamask wallets as follows:
 * ```javascript
 * import { useMetamask } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithMetamask = useMetamask()
 *
 *   return (
 *     <button onClick={connectWithMetamask}>
 *       Connect Metamask
 *     </button>
 *   )
 * }
 * ```
 * Here, we use the `useMetamask` hook to handle metamask connection.
 * When a user clicks the button, we'll call the `connectWithMetamask` function, which will prompt users to connect their metamask wallet.
 *
 * @public
 */

function useMetamask() {
  var _window$ethereum;

  const [connectors, connect] = useConnect();
  const isMetaMaskInjected = typeof window !== "undefined" && ((_window$ethereum = window.ethereum) === null || _window$ethereum === void 0 ? void 0 : _window$ethereum.isMetaMask);
  const shouldUseWalletConnect = isMobile() && !isMetaMaskInjected; // injected connector

  const injectedConnector = connectors.data.connectors.find(c => c.id === "injected"); // walletConnect connector

  const walletConnectConnector = connectors.data.connectors.find(c => c.id === "walletConnect");
  const connector = (shouldUseWalletConnect ? walletConnectConnector : injectedConnector) || injectedConnector;
  invariant(connector, "No connector found, please make sure you provide the InjectedConnector to your <ThirdwebProvider />");
  return async () => {
    // if we don't have an injected provider
    if (!isMetaMaskInjected) {
      // this is the fallback uri that should work no matter what
      const uri = "https://metamask.app.link/dapp/".concat(window.location.toString()); // open whatever uri we end up with in a new tab

      window.open(uri, "_blank");
      return Promise.resolve({
        error: new Error("metamask not injected")
      });
    } // otherwise we have MM avaiable, so we can just use it


    return await connect(connector);
  };
}

/**
 * Hook for connecting to a mobile wallet with Wallet Connect
 *
 * ```javascript
 * import { useWalletConnect } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * We can allows user to connect their mobile wallets as follows:
 * ```javascript
 * import { useWalletConnect } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithWalletConnect = useWalletConnect()
 *
 *   return (
 *     <button onClick={connectWithWalletConnect}>
 *       Connect WalletConnect
 *     </button>
 *   )
 * }
 * ```
 *
 * When users click this button, a popup will appear on the screen prompting them to scan a QR code from their phone to connect their mobile wallets.
 * Once they scan the QR code from a wallet connect supported mobile wallet, their wallet will then be connected to the page as expected.
 *
 * @public
 */

function useWalletConnect() {
  const [connectors, connect] = useConnect();

  if (connectors.loading) {
    return () => Promise.reject("WalletConnect connector not ready to be used, yet");
  }

  const connector = connectors.data.connectors.find(c => c.id === "walletConnect");
  invariant(connector, "WalletConnect connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return () => connect(connector);
}

/**
 * Hook for connecting to a Coinbase wallet.
 *
 * ```javascript
 * import { useCoinbaseWallet } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * We can allow users to connect with Coinbase Wallet as follows:
 * ```javascript
 * import { useCoinbaseWallet } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithCoinbaseWallet = useCoinbaseWallet()
 *
 *   return (
 *     <button onClick={connectWithCoinbaseWallet}>
 *       Connect Coinbase Wallet
 *     </button>
 *   )
 * }
 * ```
 *
 * Upon clicking this button, users will be prompted with a popup asking them scan a QR code with their Coinbase Wallet.
 * Once they scan the QR code, their wallet will then be connected to the page as expected.
 *
 * @public
 */

function useCoinbaseWallet() {
  const [connectors, connect] = useConnect();

  if (connectors.loading) {
    return () => Promise.reject("Coinbase connector not ready to be used, yet");
  }

  const connector = connectors.data.connectors.find(c => c.id === "coinbasewallet");
  invariant(connector, "Coinbase connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return () => connect(connector);
}
/**
 * Convienience hook for connecting to a wallet via WalletLink (coinbase wallet)
 * @returns a function that will prompt the user to connect their wallet via WalletLink (coinbase wallet)
 * @internal
 */

function useWalletLink() {
  return useCoinbaseWallet();
}

/**
 * Hook for connecting to a Gnosis Safe. This enables multisig wallets to connect to your application and sing transactions.
 *
 * ```javascript
 * import { useGnosis } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * ```javascript
 * import { useGnosis } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithGnosis = useGnosis()
 *
 *   return (
 *     <button onClick={() => connectWithGnosis({ safeAddress: "0x...", safeChainId: 1 })}>
 *       Connect Gnosis Safe
 *     </button>
 *   )
 * }
 * ```
 *
 * @public
 */

function useGnosis() {
  const [connectors, connect] = useConnect();

  if (connectors.loading) {
    return () => Promise.reject("Gnosis connector not ready to be used, yet");
  }

  const connector = connectors.data.connectors.find(c => c.id === "gnosis");
  invariant(connector, "Gnosis connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return async config => {
    const previousConnector = connectors.data.connector;
    const previousConnectorChain = await (previousConnector === null || previousConnector === void 0 ? void 0 : previousConnector.getChainId());
    invariant(!!previousConnector, "Cannot connect to Gnosis Safe without first being connected to a personal wallet.");
    invariant(previousConnectorChain === config.safeChainId, "Gnosis safe chain id must match personal wallet chain id.");
    invariant(utils.isAddress(config.safeAddress), "Gnosis safe address must be a valid address.");
    connector.setConfiguration(previousConnector, config);
    return connect(connector);
  };
}

/**
 * Hook for connecting to an email wallet using magic link.
 * This enables users without their own wallets to connect to your application and sign transactions securely using their email.
 *
 * ```javascript
 * import { useMagic } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * Before using this hook, you first need to set up the magic configuration in your `ThirdwebProvider`, including your magic API key.
 *
 * ```javascript
 * // Add the magic configuration object to your wallet connectors
 * const connectors = [
 *   "metamask",
 *   "walletConnect",
 *   "walletLink",
 *   {
 *     name: "magic",
 *     options: {
 *       apiKey: "your-magic-api-key",
 *     }
 *   }
 * ]
 *
 * // Add the above to the walletConnectors prop of your <ThirdwebProvider />
 * const Provider = ({ children }) => (
 *   return (
 *     <ThirdwebProvider
 *       walletConnectors={connectors}
 *       // Specify remaining parameters
 *       ...
 *     >
 *       {children}
 *     </ThirdwebProvider>
 *   )
 * }
 * ```
 *
 * In order to use the hook to connect users with magic link, you just need to provide the users email to the connect function.
 *
 * You can setup the hook with the following configuration:
 * ```javascript
 * import { useMagic } from "@thirdweb-dev/react"
 * import { useState } from "react"
 *
 * const LoginWithMagicLink = () => {
 *   const connectWithMagic = useMagic()
 *   const [email, setEmail] = useState()
 *
 *   return (
 *     <div>
 *       <input value={email} onChange={(e) => setEmail(e.target.value)} />
 *       <button onClick={() => connectWithMagic({ email })}>Login</button>
 *     </div>
 *   )
 * }
 * ```
 *
 * @public
 */

function useMagic() {
  const [connectors, connect] = useConnect();

  if (connectors.loading) {
    return () => Promise.reject("Magic connector not ready to be used, yet");
  }

  const connector = connectors.data.connectors.find(c => c.id === "magic");
  invariant(connector, "Magic connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return configuration => {
    connector.setConfiguration(configuration);
    return connect(connector);
  };
}

/**
 * Hook for accessing the chain ID of the network the current wallet is connected to
 *
 * ```javascript
 * import { useChainId } from "@thirdweb-dev/react"
 * ```
 *
 * @example
 * You can get the chain ID of the connected wallet by using the hook as follows:
 * ```javascript
 * import { useChainId } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const chainId = useChainId()
 *
 *   return <div>{chainId}</div>
 * }
 * ```
 * @public
 */

function useChainId() {
  var _useNetwork$0$data$ch;

  return (_useNetwork$0$data$ch = useNetwork$1()["0"].data.chain) === null || _useNetwork$0$data$ch === void 0 ? void 0 : _useNetwork$0$data$ch.id;
}

/**
 * Hook for checking whether the connected wallet is on the correct network specified by the `desiredChainId` passed to the `<ThirdwebProvider />`.
 *
 * ```javascript
 * import { useNetworkMistmatch } from "@thirdweb-dev/react"
 * ```
 *
 * @returns `true` if the chainId of the connected wallet is different from the desired chainId passed into <ThirdwebProvider />
 *
 * @example
 * You can check if a users wallet is connected to the correct chain ID as follows:
 * ```javascript
 * import { useNetworkMismatch } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const isMismatched = useNetworkMismatch()
 *
 *   return <div>{isMismatched}</div>
 * }
 * ```
 *
 * From here, you can prompt users to switch their network using the `useNetwork` hook.
 *
 * @public
 */

function useNetworkMismatch() {
  const desiredChainId = useDesiredChainId();
  const activeChainId = useChainId();

  if (desiredChainId === -1) {
    // means no desiredChainId is set in the <ThirdwebProvider />, so we don't care about the network mismatch
    return false;
  }

  if (!activeChainId) {
    // means no wallet is connected yet, so we don't care about the network mismatch
    return false;
  } // check if the chainIds are different


  return desiredChainId !== activeChainId;
}

/**
 * Hook for getting metadata about the network the current wallet is connected to and switching networks
 *
 * @example
 * ```javascript
 * import { useNetwork, ChainId } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   const [, switchNetwork] = useNetwork();
 *
 *   return (
 *     <button onClick={() => switchNetwork(ChainId.Polygon)}>
 *        Switch Network
 *     </button>
 *   );
 * };
```
 *
 * It's important to note that some wallet apps do not support programmatic network switching and switchNetwork will be undefined.
 * For those situations, you can typically switch networks in the wallet app this hook will still work.
 *
 * @public
 */

function useNetwork() {
  return useNetwork$1();
}

/** @internal */

function useQueryWithNetwork(queryKey, queryFn, options) {
  const activeChainId = useActiveChainId();
  const mergedOptions = { ...options,
    enabled: !!(activeChainId && options !== null && options !== void 0 && options.enabled)
  };
  return useQuery(createCacheKeyWithNetwork(queryKey, activeChainId), queryFn, mergedOptions);
}

async function fetchContractType(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return;
  }

  try {
    return await sdk.resolveContractType(contractAddress);
  } catch (err) {
    // expected error, return custom type instead
    return "custom";
  }
}

async function fetchContractCompilerMetadata(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return;
  }

  return await (await sdk.getPublisher()).fetchCompilerMetadataFromAddress(contractAddress);
}

async function fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return;
  }

  const contractType = await queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.type(contractAddress), sdk._chainId), () => fetchContractType(contractAddress, sdk), // is immutable, so infinite stale time
  {
    staleTime: Infinity
  });

  if (contractType !== "custom") {
    return {
      contractType,
      compilerMetadata: null
    };
  }

  const compilerMetadata = await queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), sdk._chainId), () => fetchContractCompilerMetadata(contractAddress, sdk), // is immutable, so infinite stale time
  {
    staleTime: Infinity
  });
  return {
    contractType,
    compilerMetadata
  };
}

function getContractAbi(input) {
  if (!input || !input.contractType) {
    return null;
  }

  let contractAbi = null;

  if (input.contractType !== "custom") {
    contractAbi = CONTRACTS_MAP[input.contractType].contractAbi;
  }

  if (input.contractType === "custom" && input.compilerMetadata) {
    var _input$compilerMetada;

    contractAbi = (_input$compilerMetada = input.compilerMetadata) === null || _input$compilerMetada === void 0 ? void 0 : _input$compilerMetada.abi;
  }

  return contractAbi;
}

function getContractFromCombinedTypeAndCompilerMetadata(contractAddress, input, sdk) {
  if (!input || !sdk || !contractAddress || !input.contractType) {
    return null;
  }

  const contractAbi = getContractAbi(input);
  invariant(contractAbi, "could not resolve any ABI for contract".concat(contractAddress));
  return sdk.getContractFromAbi(contractAddress, contractAbi);
}
/**
 *
 * @internal
 *
 * @param contractAddress - contract address
 * @returns the contract abi
 */


function useContractAbi(contractAddress) {
  var _contractTypeAndCompi;

  const sdk = useSDK();
  const contractTypeAndCompilerMetadata = useContractTypeAndCompilerMetadata(contractAddress);

  if (!contractAddress || !sdk || !((_contractTypeAndCompi = contractTypeAndCompilerMetadata.data) !== null && _contractTypeAndCompi !== void 0 && _contractTypeAndCompi.contractType)) {
    return { ...contractTypeAndCompilerMetadata,
      abi: null
    };
  }

  const abi = getContractAbi(contractTypeAndCompilerMetadata.data);
  return { ...contractTypeAndCompilerMetadata,
    abi
  };
}
/**
 * Use this to get the contract type for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractType, isLoading, error } = useContractType("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract type of the contract
 * @beta
 */

function useContractType(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(cacheKeys.contract.type(contractAddress), () => fetchContractType(contractAddress, sdk), {
    enabled: !!sdk && !!contractAddress,
    // never stale, a contract's publish metadata is immutable
    staleTime: Infinity
  });
}
/**
 * Use this to get the publish metadata for a deployed contract.
 *
 * @example
 * ```javascript
 * const { data: compilerMetadata, isLoading, error } = useContractCompilerMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the published metadata (name, abi, bytecode) of the contract
 * @beta
 */

function useContractCompilerMetadata(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), () => fetchContractCompilerMetadata(contractAddress, sdk), {
    enabled: !!sdk && !!contractAddress,
    // never stale, a contract's publish metadata is immutable
    staleTime: Infinity
  });
}
/**
 * @internal
 */

function useContractTypeAndCompilerMetadata(contractAddress) {
  const sdk = useSDK();
  const queryClient = useQueryClient();
  return useQueryWithNetwork(cacheKeys.contract.typeAndCompilerMetadata(contractAddress), () => fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk), {
    enabled: !!sdk && !!contractAddress,
    // combination of type and publish metadata is immutable
    staleTime: Infinity
  });
}
/**
 * Use this resolve a contract address to a smart contract instance.
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract once it is resolved
 * @public
 */


function useContract(contractAddress) {
  var _contractTypeAndCompi2;

  const sdk = useSDK();
  const contractTypeAndCompilerMetadata = useContractTypeAndCompilerMetadata(contractAddress);

  if (!contractAddress || !sdk || !((_contractTypeAndCompi2 = contractTypeAndCompilerMetadata.data) !== null && _contractTypeAndCompi2 !== void 0 && _contractTypeAndCompi2.contractType)) {
    return { ...contractTypeAndCompilerMetadata,
      contract: null
    };
  }

  const contract = getContractFromCombinedTypeAndCompilerMetadata(contractAddress, contractTypeAndCompilerMetadata.data, sdk);
  return { ...contractTypeAndCompilerMetadata,
    contract
  };
}
/**
 * Use this to get the contract metadata for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractMetadata, isLoading, error } = useContractMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract metadata of the deployed contract
 * @beta
 */

function useContractMetadata(contractAddress) {
  const sdk = useSDK();
  const queryClient = useQueryClient();
  const activeChainId = useActiveChainId();
  return useQueryWithNetwork(cacheKeys.contract.metadata(contractAddress), async () => {
    var _contract$metadata;

    const typeAndCompilerMetadata = await queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.typeAndCompilerMetadata(contractAddress), activeChainId), () => fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk), // is immutable, so infinite stale time
    {
      staleTime: Infinity
    });
    const contract = getContractFromCombinedTypeAndCompilerMetadata(contractAddress, typeAndCompilerMetadata, sdk);
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$metadata = contract.metadata) === null || _contract$metadata === void 0 ? void 0 : _contract$metadata.get, "contract metadata is not available");
    return await contract.metadata.get();
  }, {
    enabled: !!contractAddress || !!sdk
  });
}
/**
 @internal
 */

function useContractFunctions(contractAddress) {
  const sdk = useSDK();
  const queryClient = useQueryClient();
  const activeChainId = useActiveChainId();
  return useQueryWithNetwork(cacheKeys.contract.extractFunctions(contractAddress), async () => {
    const typeAndCompilerMetadata = await queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.typeAndCompilerMetadata(contractAddress), activeChainId), () => fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk), // is immutable, so infinite stale time
    {
      staleTime: Infinity
    });
    const contract = getContractFromCombinedTypeAndCompilerMetadata(contractAddress, typeAndCompilerMetadata, sdk);

    if (contract !== null && contract !== void 0 && contract.publishedMetadata.extractFunctions) {
      return contract.publishedMetadata.extractFunctions();
    }

    return null;
  }, {
    enabled: !!contractAddress || !!sdk,
    // functions are based on publish metadata (abi), so this is immutable
    staleTime: Infinity
  });
}
/**
 * Use this to get data from a contract read-function call.
 *
 * @example
 * ```javascript
 * const { contract } = useContract("{{contract_address}}");
 * const { data, isLoading, error } = useContractData(contract, "functionName", ...args);
 *```
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param functionName - the name of the function to call
 * @param args - The arguments to pass to the function (if any), with optional call arguments as the last parameter
 * @returns a response object that includes the data returned by the function call
 *
 * @beta
 */

function useContractData(contract, functionName) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.call(contractAddress, functionName, args), () => {
    invariant(contract, "contract must be defined");
    invariant(functionName, "function name must be provided");
    return contract.call(functionName, ...args);
  }, {
    enabled: !!contract && !!functionName
  });
}
/**
 * Use this to get a function to make a write call to your contract
 *
 * @example
 * ```javascript
 * const { contract } = useContract("{{contract_address}}");
 * const { mutate: myFunction, isLoading, error } = useContractCall(contract, "myFunction");
 *
 * // the function can be called as follows:
 * // myFunction(["param 1", "param 2", ...])
 *```
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param functionName - the name of the function to call
 * @returns a response object that includes the write function to call
 *
 * @beta
 */

function useContractCall(contract, functionName) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async callParams => {
    invariant(contract, "contract must be defined");
    invariant(functionName, "function name must be provided");

    if (!(callParams !== null && callParams !== void 0 && callParams.length)) {
      return contract.call(functionName);
    }

    return contract.call(functionName, ...callParams);
  }, {
    onSettled: () => queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), activeChainId))
  });
}
/**
 * Use this to query (and subscribe) to all events on a contract.
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param options - options incldues the filters ({@link QueryAllEvents}) for the query as well as if you want to subscribe to real-time updates (default: true)
 * @returns a response object that includes the contract events
 * @beta
 */

function useAllContractEvents(contract) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    subscribe: true
  };
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryEnabled = !!contract;
  const queryClient = useQueryClient();
  const activeChainId = useActiveChainId();
  const cacheKey = useMemo(() => createCacheKeyWithNetwork(cacheKeys.contract.events.getAllEvents(contractAddress), activeChainId), [activeChainId, contractAddress]);
  useEffect(() => {
    // if we're not subscribing or query is not enabled yet we can early exit
    if (!options.subscribe || !queryEnabled || !contract) {
      return;
    }

    const cleanupListener = contract.events.listenToAllEvents(contractEvent => {
      // insert new event to the front of the array (no duplicates, though)
      queryClient.setQueryData(cacheKey, oldData => {
        if (!oldData) {
          return [contractEvent];
        }

        const eventIsNotAlreadyInEventsList = oldData.findIndex(e => e.transaction.transactionHash === contractEvent.transaction.transactionHash && e.transaction.logIndex === contractEvent.transaction.logIndex) === -1;

        if (eventIsNotAlreadyInEventsList) {
          return [contractEvent, ...oldData];
        }

        return oldData;
      });
    }); // cleanup listener on unmount

    return cleanupListener;
  }, [queryEnabled, options.subscribe, cacheKey, contract, queryClient]);
  return useQuery(cacheKey, () => {
    invariant(contract, "contract must be defined");
    return contract.events.getAllEvents(options.queryFilter);
  }, {
    enabled: queryEnabled,
    // we do not need to re-fetch if we're subscribing
    refetchOnWindowFocus: !options.subscribe,
    refetchOnMount: true,
    refetchOnReconnect: true
  });
}
/**
 * Use this to query (and subscribe) to a specific event on a contract.
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param options - options incldues the filters ({@link QueryAllEvents}) for the query as well as if you want to subscribe to real-time updates (default: true)
 * @returns a response object that includes the contract events
 * @beta
 */

function useContractEvents(contract, eventName) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    subscribe: true
  };
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryEnabled = !!contract && !!eventName;
  const queryClient = useQueryClient();
  const activeChainId = useActiveChainId();
  const cacheKey = useMemo(() => createCacheKeyWithNetwork(cacheKeys.contract.events.getAllEvents(contractAddress), activeChainId), [activeChainId, contractAddress]);
  useEffect(() => {
    // if we're not subscribing or query is not enabled yet we can early exit
    if (!options.subscribe || !queryEnabled || !contract || !eventName) {
      return;
    }

    const cleanupListener = contract.events.listenToAllEvents(contractEvent => {
      // insert new event to the front of the array (no duplicates, though)
      queryClient.setQueryData(cacheKey, oldData => {
        if (!oldData) {
          return [contractEvent];
        }

        const eventIsNotAlreadyInEventsList = oldData.findIndex(e => e.transaction.transactionHash === contractEvent.transaction.transactionHash && e.transaction.logIndex === contractEvent.transaction.logIndex) === -1;

        if (eventIsNotAlreadyInEventsList) {
          return [contractEvent, ...oldData];
        }

        return oldData;
      });
    }); // cleanup listener on unmount

    return cleanupListener;
  }, [queryEnabled, options.subscribe, cacheKey, eventName, contract, queryClient]);
  return useQuery(cacheKey, () => {
    invariant(contract, "contract must be defined");
    return contract.events.getEvents(eventName, options.queryFilter);
  }, {
    enabled: queryEnabled,
    // we do not need to re-fetch if we're subscribing
    refetchOnWindowFocus: !options.subscribe,
    refetchOnMount: true,
    refetchOnReconnect: true
  });
}

/**
 * @internal
 */

function convertResponseToNFTType(contract, metadata) {
  if (contract.featureName === "ERC721") {
    return {
      type: "ERC721",
      supply: 1,
      owner: "",
      ...metadata
    };
  }

  return {
    type: "ERC1155",
    supply: 0,
    owner: "",
    ...metadata
  };
}
/**
 * @internal
 */


function convertResponseToNFTTypeArray(contract, metadata) {
  return metadata.map(m => convertResponseToNFTType(contract, m));
}
/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get an individual NFT token of your {@link NFTContract}.
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: nft, isLoading, error } = useNFT(nftDrop, <tokenId>);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: nft, isLoading, error } = useNFT(contract?.nft, <tokenId>);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param tokenId - the tokenId to look up
 * @returns a response object that includes the metadata for the given tokenId
 * @beta
 */


function useNFT(contract, tokenId) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.get(contractAddress, tokenId), async () => {
    invariant(contract, "No Contract instance provided");
    invariant(contract.get, "Contract instance does not support get");
    return convertResponseToNFTType(contract, await contract.get(BigNumber.from(tokenId || 0)));
  }, {
    enabled: !!contract && tokenId !== undefined
  });
}
/**
 * Use this to get a list of NFT tokens of your {@link NFTContract}.
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: nfts, isLoading, error } = useNFTs(nftDrop, { start: 0, count: 100 });
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: nfts, isLoading, error } = useNFTs(contract?.nft, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param queryParams - query params to pass to the query for the sake of pagination
 * @returns a response object that includes an array of NFTs
 * @beta
 */

function useNFTs(contract, queryParams) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.all(contractAddress, queryParams), async () => {
    var _contract$query;

    invariant(contract, "No Contract instance provided");
    invariant((_contract$query = contract.query) === null || _contract$query === void 0 ? void 0 : _contract$query.all, "Contract instance does not support query.all");
    return convertResponseToNFTTypeArray(contract, await contract.query.all(queryParams));
  }, {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a the total (minted) supply of your {@link NFTContract}.
 *
 *  * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: totalSupply, isLoading, error } = useNFTSupply(nftDrop);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: totalSupply, isLoading, error } = useNFTSupply(contract?.nft);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a response object that incudes the total minted supply
 * @beta
 */

function useTotalCirculatingSupply() {
  for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
    _ref[_key] = arguments[_key];
  }

  let [contract, tokenId] = _ref;
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCirculatingSupply(contractAddress), () => {
    var _contract$query3;

    invariant(contract, "No Contract instance provided");

    if (contract.featureName === "ERC721") {
      var _contract$query2;

      invariant(contract === null || contract === void 0 ? void 0 : (_contract$query2 = contract.query) === null || _contract$query2 === void 0 ? void 0 : _contract$query2.totalCirculatingSupply, "Contract instance does not support query.totalCirculatingSupply");
      return contract.query.totalCirculatingSupply();
    }

    invariant((_contract$query3 = contract.query) === null || _contract$query3 === void 0 ? void 0 : _contract$query3.totalCirculatingSupply, "Contract instance does not support query.getTotalCount");
    invariant(tokenId, "No tokenId provided");
    return contract.query.totalCirculatingSupply(tokenId);
  }, {
    enabled: !!contract
  });
}
/**
 * Use this to get a the number of tokens in your {@link NFTContract}.
 *
 * @remarks The `total count` and `total supply` are the same for {@link ERC721} based contracts.
 * For {@link ERC1155} the `total count` is the number of NFTs that exist on the contract, **not** the sum of all supply of each token. (Since ERC1155 can have multiple owners per token.)
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: totalCount, isLoading, error } = useTotalCount(nftDrop);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: totalCount, isLoading, error } = useTotalCount(contract?.nft);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a response object that incudes the total number of tokens in the contract
 * @beta
 */

function useTotalCount(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCount(contractAddress), () => {
    var _contract$query4;

    invariant(contract, "No Contract instance provided");
    invariant((_contract$query4 = contract.query) === null || _contract$query4 === void 0 ? void 0 : _contract$query4.totalCount, "Contract instance does not support query.totalCount");
    return contract.query.totalCount();
  }, {
    enabled: !!contract
  });
}
/**
 * Use this to get a the owned NFTs for a specific {@link NFTContract} and wallet address.
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: ownedNFTs, isLoading, error } = useOwnedNFTs(nftDrop, <OwnerWalletAddress>);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: ownedNFTs, isLoading, error } = useOwnedNFTs(contract?.nft, <OwnerWalletAddress>);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param ownerWalletAddress - the wallet adress to get owned tokens for
 * @returns a response object that includes the list of owned tokens
 * @beta
 */

function useOwnedNFTs(contract, ownerWalletAddress) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.owned.all(contractAddress, ownerWalletAddress), async () => {
    var _contract$query6;

    invariant(contract, "No Contract instance provided");

    if (contract.featureName === "ERC721") {
      var _contract$query5, _contract$query5$owne;

      invariant((_contract$query5 = contract.query) === null || _contract$query5 === void 0 ? void 0 : (_contract$query5$owne = _contract$query5.owned) === null || _contract$query5$owne === void 0 ? void 0 : _contract$query5$owne.all, "Contract instance does not support query.owned.all");
      return convertResponseToNFTTypeArray(contract, await contract.query.owned.all(ownerWalletAddress));
    }

    invariant((_contract$query6 = contract.query) === null || _contract$query6 === void 0 ? void 0 : _contract$query6.owned, "Contract instance does not support query.owned");
    return convertResponseToNFTTypeArray(contract, await contract.query.owned(ownerWalletAddress));
  }, {
    enabled: !!contract && !!ownerWalletAddress
  });
}
/**
 * Use this to get a the total balance of a {@link NFTContract} and wallet address.
 *
 *  @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: ownerBalance, isLoading, error } = useNFTBalance(nftDrop, <OwnerWalletAddress>);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: ownerBalance, isLoading, error } = useNFTBalance(contract?.nft, <OwnerWalletAddress>);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param ownerWalletAddress - the wallet adress to check the balance of
 * @returns a response object that includes the total balance of the owner
 * @beta
 */

function useNFTBalance() {
  for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    _ref2[_key2] = arguments[_key2];
  }

  let [contract, ownerWalletAddress, tokenId] = _ref2;
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.balanceOf(contractAddress, ownerWalletAddress, tokenId), () => {
    invariant(contract, "No Contract instance provided");
    invariant(contract.balanceOf, "Contract instance does not support balanceOf");
    invariant(ownerWalletAddress, "No owner wallet address provided");

    if (contract.featureName === "ERC1155") {
      invariant(tokenId, "No tokenId provided");
      return contract.balanceOf(ownerWalletAddress, tokenId);
    }

    return contract.balanceOf(ownerWalletAddress);
  }, {
    enabled: !!contract && !!ownerWalletAddress
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to mint a new NFT on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: mintNft,
 *     isLoading,
 *     error,
 *   } = useMintNFT(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to mint nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNft({ name: "My awesome NFT!", to: "0x..." })}
 *     >
 *       Mint!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: mintNft,
 *     isLoading,
 *     error,
 *   } = useMintNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to mint nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNft({ name: "My awesome NFT!", to: "0x..." })}
 *     >
 *       Mint!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to mint a new NFT token to the connected wallet
 * @beta
 */

function useMintNFT(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    var _contract$mint;

    invariant(data.to, 'No "to" address provided');
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$mint = contract.mint) === null || _contract$mint === void 0 ? void 0 : _contract$mint.to, "contract does not support mint.to");

    if (contract.featureName === "ERC1155") {
      invariant("supply" in data, "supply not provided");
      const {
        to,
        metadata,
        supply
      } = data;
      return await contract.mint.to(to, {
        metadata,
        supply: BigNumber.from(supply || 1)
      });
    }

    return await contract.mint.to(data.to, data.metadata);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to mint a new NFT on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: mintNftSupply,
 *     isLoading,
 *     error,
 *   } = useMintNFTSupply(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to mint additional supply", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNftSupply({ tokenId: 0, additionalSupply: 100, to: "0x..."})}
 *     >
 *       Mint Additional Supply!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: mintNftSupply,
 *     isLoading,
 *     error,
 *   } = useMintNFTSupply(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to mint additional supply", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNftSupply({ tokenId: 0, additionalSupply: 100, to: "0x..."})}
 *     >
 *       Mint Additional Supply!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link Erc1155}
 * @returns a mutation object that can be used to mint a more supply of a token id to the provided wallet
 * @beta
 */

function useMintNFTSupply(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    var _contract$mint2;

    invariant(data.to, 'No "to" address provided');
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$mint2 = contract.mint) === null || _contract$mint2 === void 0 ? void 0 : _contract$mint2.additionalSupplyTo, "contract does not support mint.additionalSupplyTo");
    invariant("tokenId" in data, "tokenId not provided");
    invariant("additionalSupply" in data, "additionalSupply not provided");
    const {
      to,
      tokenId,
      additionalSupply
    } = data;
    return await contract.mint.additionalSupplyTo(to, tokenId, additionalSupply);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to transfer tokens on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: transferNFT,
 *     isLoading,
 *     error,
 *   } = useTransferNFT(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to transfer nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferNFT({ to: "0x...", tokenId: 2 })}
 *     >
 *       Transfer NFT!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: transferNFT,
 *     isLoading,
 *     error,
 *   } = useTransferNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to transfer nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferNFT({ to: "0x...", tokenId: 2 })}
 *     >
 *       Transfer
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to transfer NFTs
 * @beta
 */

function useTransferNFT(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(data => {
    invariant(contract === null || contract === void 0 ? void 0 : contract.transfer, "contract does not support transfer");

    if (contract.featureName === "ERC1155") {
      invariant("amount" in data, "amount not provided");
      return contract.transfer(data.to, data.tokenId, data.amount);
    }

    return contract.transfer(data.to, data.tokenId);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to transfer tokens on your {@link Erc1155}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const editionDrop = useEditionDrop(<ContractAddress>);
 *   const {
 *     mutate: airdropNFT,
 *     isLoading,
 *     error,
 *   } = useAirdropNFT(editionDrop);
 *
 *   if (error) {
 *     console.error("failed to transfer batch NFTs", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => airdropNFT({
 *          tokenId: 2,
 *          addresses: [{ address: "0x...", quantity: 2 }, { address: "0x...", quantity: 4 } }]
 *       )}
 *     >
 *       Airdrop NFT
 *     </button>
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: airdropNFT,
 *     isLoading,
 *     error,
 *   } = useAirdropNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to transfer batch NFTs", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => airdropNFT({
 *          tokenId: 2,
 *          addresses: [{ address: "0x...", quantity: 2 }, { address: "0x...", quantity: 4 } }]
 *       )}
 *     >
 *       Airdrop NFT
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link Erc1155}
 * @returns a mutation object that can be used to transfer batch NFTs
 * @beta
 */

function useAirdropNFT(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(_ref3 => {
    let {
      tokenId,
      addresses
    } = _ref3;
    invariant(contract === null || contract === void 0 ? void 0 : contract.airdrop, "contract does not support airdrop");
    return contract.airdrop(tokenId, addresses);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to burn an NFT on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: burnNft,
 *     isLoading,
 *     error,
 *   } = useBurnNFT(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to burn nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => burnNft({ tokenId: 0 })}
 *     >
 *       Burn!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: burnNft,
 *     isLoading,
 *     error,
 *   } = useBurnNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to burn nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => burnNft({ tokenId: 0 })}
 *     >
 *       Burn!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to burn an NFT token from the connected wallet
 * @beta
 */

function useBurnNFT(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    invariant(data.tokenId, "No tokenId provided");
    invariant(contract === null || contract === void 0 ? void 0 : contract.burn, "contract does not support burn");

    if (contract.featureName === "ERC1155") {
      invariant("amount" in data, "amount not provided");
      const {
        tokenId,
        amount
      } = data;
      return await contract.burn.tokens(tokenId, amount);
    }

    const {
      tokenId
    } = data;
    return await contract.burn.token(tokenId);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/

/**       READ HOOKS    **/

/** **********************/

/**
 * Use this to get a list of *unclaimed* NFT tokens of your ERC721 Drop contract.
 *
 * @example
 * ```javascript
 * const { data: unclaimedNfts, isLoading, error } = useUnclaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a contract that extends the Erc721 spec (nft drop, custom contract that follows the Erc721 & drop spec)
 * @param queryParams - query params to pass to the query for the sake of pagination
 * @returns a response object that includes an array of NFTs that are unclaimed
 * @beta
 */

function useUnclaimedNFTs(contract, queryParams) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.getAllUnclaimed(contractAddress, queryParams), () => {
    invariant(contract, "No Contract instance provided");
    invariant(contract.getAllUnclaimed, "Contract instance does not support getAllUnclaimed");
    return contract.getAllUnclaimed(queryParams);
  }, {
    enabled: !!contract
  });
}
/**
 * Use this to get a list of *claimed* (minted) NFT tokens of your ERC721 Drop contract.
 *
 * @remarks Equivalent to using {@link useNFTs}.
 *
 * @example
 * ```javascript
 * const { data: claimedNFTs, isLoading, error } = useClaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a {@link DropContract}
 * @param queryParams - query params to pass to the query for the sake of pagination
 * @returns a response object that includes an array of NFTs that are claimed
 * @beta
 */

function useClaimedNFTs(contract, queryParams) {
  return useNFTs(contract, queryParams);
}
/**
 *
 * @param contract - an instance of a {@link NFTDrop}
 * @returns a response object that includes the number of NFTs that are unclaimed
 */

function useUnclaimedNFTSupply(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalUnclaimedSupply(contractAddress), () => {
    invariant(contract, "No Contract instance provided");
    invariant(contract.totalUnclaimedSupply, "Contract instance does not support totalUnclaimedSupply");
    return contract.totalUnclaimedSupply();
  }, {
    enabled: !!contract
  });
}
/**
 *
 * @param contract - an instance of a {@link DropContract}
 * @returns a response object that includes the number of NFTs that are claimed
 */

function useClaimedNFTSupply(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalClaimedSupply(contractAddress), () => {
    invariant(contract, "No Contract instance provided");

    if (contract.featureName === "ERC1155") {
      return contract.getTotalCount();
    }

    invariant(contract.totalClaimedSupply, "Contract instance does not support totalClaimedSupply");
    return contract.totalClaimedSupply();
  }, {
    enabled: !!contract
  });
}
/**
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a response object that gets the batches to still be revealed
 */

function useBatchesToReveal(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.revealer.getBatchesToReveal(contractAddress), () => {
    var _contract$drop, _contract$drop$reveal;

    invariant(contract, "No Contract instance provided");
    invariant((_contract$drop = contract.drop) === null || _contract$drop === void 0 ? void 0 : (_contract$drop$reveal = _contract$drop.revealer) === null || _contract$drop$reveal === void 0 ? void 0 : _contract$drop$reveal.getBatchesToReveal, "Contract instance does not support drop.revealer.getBatchesToReveal");
    return contract.drop.revealer.getBatchesToReveal();
  }, {
    enabled: !!contract
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to claim a NFT on your {@link DropContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: claimNft,
 *     isLoading,
 *     error,
 *   } = useClaimNFT(DropContract);
 *
 *   if (error) {
 *     console.error("failed to claim nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => claimNft({ to: "0x...", quantity: 1 })}
 *     >
 *       Claim NFT!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link DropContract}
 * @returns a mutation object that can be used to claim a NFT to the wallet specificed in the params
 * @beta
 */

function useClaimNFT(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    invariant(data.to, 'No "to" address provided');
    invariant(contract === null || contract === void 0 ? void 0 : contract.claimTo, "contract does not support claimTo");

    if (contract.featureName === "ERC1155") {
      invariant("tokenId" in data, "tokenId not provided");
      const {
        to,
        tokenId,
        quantity
      } = data;
      return await contract.claimTo(to, tokenId, quantity, data.checkERC20Allowance);
    }

    return await contract.claimTo(data.to, data.quantity, data.checkERC20Allowance);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to lazy mint a batch of NFTs on your {@link DropContract}
 *
 * @param contract - an instance of a {@link NFTContract} with the drop extension
 * @param onProgress - an optional callback that will be called with the progress of the upload
 * @returns a mutation object that can be used to lazy mint a batch of NFTs
 * @beta
 */

function useLazyMint(contract, onProgress) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    var _contract$drop2;

    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop2 = contract.drop) === null || _contract$drop2 === void 0 ? void 0 : _contract$drop2.lazyMint, "contract does not support drop.lazyMint");
    let options;

    if (onProgress) {
      options = {
        onProgress
      };
    }

    return await contract.drop.lazyMint(data.metadatas, options);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to lazy mint a batch of delayed reveal NFTs on your {@link DropContract}
 *
 * @param contract - an instance of a {@link NFTContract} with the drop extension
 * @param onProgress - an optional callback that will be called with the progress of the upload
 * @returns a mutation object that can be used to lazy mint a batch of NFTs
 * @beta
 */

function useDelayedRevealLazyMint(contract, onProgress) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    var _contract$drop3, _contract$drop3$revea;

    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop3 = contract.drop) === null || _contract$drop3 === void 0 ? void 0 : (_contract$drop3$revea = _contract$drop3.revealer) === null || _contract$drop3$revea === void 0 ? void 0 : _contract$drop3$revea.createDelayedRevealBatch, "contract does not support drop.revealer.createDelayedRevealBatch");
    let options;

    if (onProgress) {
      options = {
        onProgress
      };
    }

    return await contract.drop.revealer.createDelayedRevealBatch(data.placeholder, data.metadatas, data.password, options);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to reveal a batch of delayed reveal NFTs on your {@link DropContract}
 *
 * @param contract - an instance of a {@link NFTContract} with the drop extension
 * @returns a mutation object that can be used to reveal a batch of delayed reveal NFTs
 * @beta
 */

function useRevealLazyMint(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    var _contract$drop4, _contract$drop4$revea;

    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop4 = contract.drop) === null || _contract$drop4 === void 0 ? void 0 : (_contract$drop4$revea = _contract$drop4.revealer) === null || _contract$drop4$revea === void 0 ? void 0 : _contract$drop4$revea.reveal, "contract does not support drop.revealer.reveal");
    return await contract.drop.revealer.reveal(data.batchId, data.password);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get a specific listing from the marketplace.
 *
 * @example
 * ```javascript
 * const { data: listing, isLoading, error } = useListing(<YourMarketplaceContractInstance>, <listingId>);
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param listingId - the listing id to check
 * @returns a response object that includes an array of listings
 * @beta
 */

function useListing(contract, listingId) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getListing(contractAddress, listingId), () => {
    invariant(contract, "No Contract instance provided");
    return contract.getListing(BigNumber.from(listingId || 0));
  }, {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a list all listings from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: listings, isLoading, error } = useListings(<YourMarketplaceContractInstance>, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param filter - filter to pass to the query for the sake of pagination & filtering
 * @returns a response object that includes an array of listings
 * @beta
 */

function useListings(contract, filter) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getAllListings(contractAddress, filter), () => {
    invariant(contract, "No Contract instance provided");
    return contract.getAllListings(filter);
  }, {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a list active listings from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: listings, isLoading, error } = useActiveListings(<YourMarketplaceContractInstance>, { seller: "0x...", tokenContract: "0x...", tokenId: 1, start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param filter - filter to pass to the query for the sake of pagination & filtering
 * @returns a response object that includes an array of listings
 * @beta
 */

function useActiveListings(contract, filter) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getActiveListings(contractAddress, filter), () => {
    invariant(contract, "No Contract instance provided");
    return contract.getActiveListings(filter);
  }, {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a the winning bid for an auction listing from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: winningBid, isLoading, error } = useWinningBid(<YourMarketplaceContractInstance>, <listingId>);
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param listingId - the listing id to check
 * @returns a response object that includes the {@link Offer} that is winning the auction
 * @beta
 */

function useWinningBid(contract, listingId) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinningBid(contractAddress, listingId), () => {
    invariant(contract, "No Contract instance provided");
    return contract.auction.getWinningBid(BigNumber.from(listingId || 0));
  }, {
    enabled: !!contract && listingId !== undefined
  });
}
/**
 * Use this to get the winner of an auction listing from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: auctionWinner, isLoading, error } = useAuctionWinner(<YourMarketplaceContractInstance>, <listingId>);
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param listingId - the listing id to check
 * @returns a response object that includes the address of the winner of the auction or undefined if there is no winner yet
 * @beta
 */

function useAuctionWinner(contract, listingId) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinner(contractAddress, listingId), async () => {
    invariant(contract, "No Contract instance provided");
    let winner;

    try {
      winner = await contract.auction.getWinner(BigNumber.from(listingId || 0));
    } catch (err) {
      var _message;

      if (!(err !== null && err !== void 0 && (_message = err.message) !== null && _message !== void 0 && _message.includes("Could not find auction"))) {
        throw err;
      }
    }

    return winner;
  }, {
    enabled: !!contract && listingId !== undefined
  });
}
/**
 * Use this to get the buffer in basis points between offers from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: auctionWinner, isLoading, error } = useBidBuffer(<YourMarketplaceContractInstance>);
 * ```
 *
 * @param contract - an instance of a marketplace contract

 * @returns a response object that includes an array of listings
 * @beta
 */

function useBidBuffer(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getBidBufferBps(contractAddress), () => {
    invariant(contract, "No Contract instance provided");
    return contract.getBidBufferBps();
  }, {
    enabled: !!contract
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to create a new Direct Listing on your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: createDirectListing,
 *     isLoading,
 *     error,
 *   } = useCreateDirectListing(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to create direct listing", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => createDirectListing(directListingData)}
 *     >
 *       Create Direct Listing!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to create a new direct listing
 * @beta
 */

function useCreateDirectListing(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async data => {
    var _contract$direct;

    invariant(walletAddress, "no wallet connected, cannot create listing");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$direct = contract.direct) === null || _contract$direct === void 0 ? void 0 : _contract$direct.createListing, "contract does not support direct.createListing");
    return await contract.direct.createListing(data);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to create a new Auction Listing on your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: createAuctionListing,
 *     isLoading,
 *     error,
 *   } = useCreateAuctionListing(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to create auction listing", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => createAuctionListing(auctionListingData)}
 *     >
 *       Create Auction Listing!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to create a new auction listing
 * @beta
 */

function useCreateAuctionListing(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async data => {
    var _contract$direct2;

    invariant(walletAddress, "no wallet connected, cannot create listing");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$direct2 = contract.direct) === null || _contract$direct2 === void 0 ? void 0 : _contract$direct2.createListing, "contract does not support auction.createListing");
    return await contract.auction.createListing(data);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to place a bid on an auction listing from your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: makeBid,
 *     isLoading,
 *     error,
 *   } = useMakeBid(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to make a bid", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => makeBid({ listingId: 1, bid: 2 })}
 *     >
 *       Bid!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to make a bid on an auction listing
 * @beta
 */

function useMakeBid(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async data => {
    var _contract$auction;

    invariant(walletAddress, "no wallet connected, cannot make bid");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$auction = contract.auction) === null || _contract$auction === void 0 ? void 0 : _contract$auction.makeBid, "contract does not support auction.makeBid");
    return await contract.auction.makeBid(data.listingId, data.bid);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to buy out an auction listing from your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: buyNow,
 *     isLoading,
 *     error,
 *   } = useBuyNow(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to buyout listing", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => buyNow({listingId: 1, type: ListingType.Auction})}
 *     >
 *       Buy listing!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to buy out an auction listing
 * @beta
 */

function useBuyNow(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async data => {
    var _contract$auction2;

    invariant(walletAddress, "no wallet connected, cannot make bid");

    if (data.type === ListingType.Direct) {
      invariant(contract === null || contract === void 0 ? void 0 : contract.direct.buyoutListing, "contract does not support direct.buyoutListing");
      return await contract.direct.buyoutListing(data.id, data.buyAmount, data.buyForWallet);
    }

    invariant(contract === null || contract === void 0 ? void 0 : (_contract$auction2 = contract.auction) === null || _contract$auction2 === void 0 ? void 0 : _contract$auction2.buyoutListing, "contract does not support auction.buyoutListing");
    return await contract.auction.buyoutListing(data.id);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get a the total supply of your {@link Erc20} contract.
 *
 * @example
 * ```javascript
 * const { data: totalSupply, isLoading, error } = useTokenSupply(<YourTokenContractInstance>);
 * ```
 *
 * @param contract - an instance of a Token contract.
 * @returns a response object that incudes the total minted supply
 * @beta
 */

function useTokenSupply(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.token.totalSupply(contractAddress), () => {
    invariant(contract, "No Contract instance provided");
    return contract.totalSupply();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to get the balance of your {@link Erc20} contract for a given address.
 *
 * @example
 * ```javascript
 * const { data: balance, isLoading, error } = useTokenBalance(<YourTokenContractInstance>);
 * ```
 *
 * @param contract - an instance of a Token contract.
 * @returns a response object that includes the balance of the address
 * @beta
 */

function useTokenBalance(contract, walletAddress) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.token.balanceOf(contractAddress, walletAddress), async () => {
    invariant(contract, "No Contract instance provided");
    invariant(walletAddress, "No address provided");
    return await contract.balanceOf(walletAddress);
  }, {
    enabled: !!walletAddress && !!contract
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to mint new tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: mintTokens,
 *     isLoading,
 *     error,
 *   } = useMintToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to mint tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintTokens({ to: "0x...", amount: 1000 })}
 *     >
 *       Mint!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to mint new tokens to the connected wallet
 * @beta
 */

function useMintToken(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(data => {
    var _contract$mint;

    const {
      to,
      amount
    } = data;
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$mint = contract.mint) === null || _contract$mint === void 0 ? void 0 : _contract$mint.to, "contract does not support mint.to");
    return contract.mint.to(to, amount);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to claim tokens on your {@link TokenDrop}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: claimTokens,
 *     isLoading,
 *     error,
 *   } = useClaimToken(TokenDropContract);
 *
 *   if (error) {
 *     console.error("failed to claim tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => claimTokens({ to: "0x...", amount: 100 })}
 *     >
 *       Claim Tokens!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link TokenDrop}
 * @returns a mutation object that can be used to tokens to the wallet specificed in the params
 * @beta
 */

function useClaimToken(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    invariant(data.to, 'No "to" address provided');
    invariant(contract === null || contract === void 0 ? void 0 : contract.claimTo, "contract does not support claimTo");
    return await contract.claimTo(data.to, data.amount, data.checkERC20Allowance);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to transfer tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: transferTokens,
 *     isLoading,
 *     error,
 *   } = useTransferToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to transfer tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferTokens({ to: "0x...", amount: 1000 })}
 *     >
 *       Transfer
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to transfer tokens
 * @beta
 */

function useTransferToken(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(data => {
    const {
      to,
      amount
    } = data;
    invariant(contract === null || contract === void 0 ? void 0 : contract.transfer, "contract does not support transfer");
    return contract.transfer(to, amount);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to transfer batch tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: transferBatchTokens,
 *     isLoading,
 *     error,
 *   } = useTransferToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to transfer batch tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferBatchTokens([{ to: "0x...", amount: 1000 }, { to: "0x...", amount: 2000 }])}
 *     >
 *       Transfer Batch
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to transfer batch tokens
 * @beta
 */

function useTransferBatchToken(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(data => {
    invariant(contract === null || contract === void 0 ? void 0 : contract.transferBatch, "contract does not support transferBatch");
    const convertedData = data.map(token => ({
      toAddress: token.to,
      amount: token.amount
    }));
    return contract.transferBatch(convertedData);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to burn tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: burnTokens,
 *     isLoading,
 *     error,
 *   } = useBurnToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to burn tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => burnTokens({ amount: 1000 })}
 *     >
 *       Burn!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to burn tokens from the connected wallet
 * @beta
 */

function useBurnToken(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(data => {
    const {
      amount
    } = data;
    invariant(contract === null || contract === void 0 ? void 0 : contract.burn, "contract does not support burn");
    return contract.burn.tokens(amount);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get the active claim conditon for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.
 *
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC20ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC721ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC1155ContractInstance>, <tokenId>);
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.
 * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)
 * @returns a response object with the currently active claim condition
 *
 * @beta
 */
function useActiveClaimCondition() {
  for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
    _ref[_key] = arguments[_key];
  }

  let [contract, tokenId] = _ref;
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getActive(contractAddress, tokenId), () => {
    var _contract$drop, _contract$drop$claim, _contract$drop$claim$, _contract$drop3, _contract$drop3$claim, _contract$drop3$claim2;

    invariant(contract, "No Contract instance provided");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop = contract.drop) === null || _contract$drop === void 0 ? void 0 : (_contract$drop$claim = _contract$drop.claim) === null || _contract$drop$claim === void 0 ? void 0 : (_contract$drop$claim$ = _contract$drop$claim.conditions) === null || _contract$drop$claim$ === void 0 ? void 0 : _contract$drop$claim$.getActive, "Contract instance does not support contract?.drop?.claim?.conditions.getActive");

    if (contract.featureName === "ERC1155") {
      var _contract$drop2, _contract$drop2$claim, _contract$drop2$claim2;

      invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return contract === null || contract === void 0 ? void 0 : (_contract$drop2 = contract.drop) === null || _contract$drop2 === void 0 ? void 0 : (_contract$drop2$claim = _contract$drop2.claim) === null || _contract$drop2$claim === void 0 ? void 0 : (_contract$drop2$claim2 = _contract$drop2$claim.conditions) === null || _contract$drop2$claim2 === void 0 ? void 0 : _contract$drop2$claim2.getActive(tokenId);
    }

    return contract === null || contract === void 0 ? void 0 : (_contract$drop3 = contract.drop) === null || _contract$drop3 === void 0 ? void 0 : (_contract$drop3$claim = _contract$drop3.claim) === null || _contract$drop3$claim === void 0 ? void 0 : (_contract$drop3$claim2 = _contract$drop3$claim.conditions) === null || _contract$drop3$claim2 === void 0 ? void 0 : _contract$drop3$claim2.getActive();
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => contract has to still be provided
    enabled: (contract === null || contract === void 0 ? void 0 : contract.featureName) === "ERC1155" ? tokenId !== undefined : !!contract
  });
}
/**
 * Use this to get all claim conditons for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.
 *
 * @example
 * ```javascript
 * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC20ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC721ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC1155ContractInstance>, <tokenId>);
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.
 * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)
 * @returns a response object with the list of claim conditions
 *
 * @beta
 */

function useClaimConditions() {
  for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    _ref2[_key2] = arguments[_key2];
  }

  let [contract, tokenId] = _ref2;
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getAll(contractAddress, tokenId), () => {
    var _contract$drop4, _contract$drop4$claim, _contract$drop4$claim2, _contract$drop6, _contract$drop6$claim, _contract$drop6$claim2;

    invariant(contract, "No Contract instance provided");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop4 = contract.drop) === null || _contract$drop4 === void 0 ? void 0 : (_contract$drop4$claim = _contract$drop4.claim) === null || _contract$drop4$claim === void 0 ? void 0 : (_contract$drop4$claim2 = _contract$drop4$claim.conditions) === null || _contract$drop4$claim2 === void 0 ? void 0 : _contract$drop4$claim2.getAll, "Contract instance does not support drop.claim.conditions.getAll");

    if (contract.featureName === "ERC1155") {
      var _contract$drop5, _contract$drop5$claim, _contract$drop5$claim2;

      invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return contract === null || contract === void 0 ? void 0 : (_contract$drop5 = contract.drop) === null || _contract$drop5 === void 0 ? void 0 : (_contract$drop5$claim = _contract$drop5.claim) === null || _contract$drop5$claim === void 0 ? void 0 : (_contract$drop5$claim2 = _contract$drop5$claim.conditions) === null || _contract$drop5$claim2 === void 0 ? void 0 : _contract$drop5$claim2.getAll(tokenId);
    }

    return contract === null || contract === void 0 ? void 0 : (_contract$drop6 = contract.drop) === null || _contract$drop6 === void 0 ? void 0 : (_contract$drop6$claim = _contract$drop6.claim) === null || _contract$drop6$claim === void 0 ? void 0 : (_contract$drop6$claim2 = _contract$drop6$claim.conditions) === null || _contract$drop6$claim2 === void 0 ? void 0 : _contract$drop6$claim2.getAll();
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => contract has to still be provided
    enabled: (contract === null || contract === void 0 ? void 0 : contract.featureName) === "ERC1155" ? tokenId !== undefined : !!contract
  });
}
/**
 * Use this to check for reasons that prevent claiming for either  ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useClaimIneligibilityReasons(<YourERC20ContractInstance>, { walletAddress: <walletAddress> });
 * ```
 * @example
 * ```javascript
 * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC721ContractInstance>, { quantity: <quantity>, walletAddress: <walletAddress> });
 * ```
 * @example
 * ```javascript
 * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC1155ContractInstance>, { quantity: <quantity>, walletAddress: <walletAddress> }, <tokenId>);
 * ```
 *
 * @param contract - an instance of a contract that extends the  ERC20, ERC721 or ERC1155 spec and implements the `claimConditions` extension.
 * @param eligibilityParams - the parameters for the eligibility check, see: {@link ClaimIneligibilityParameters}
 * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)
 * @returns a response object with the resons for the claim ineligibility
 *
 * @beta
 */

function useClaimIneligibilityReasons() {
  for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    _ref3[_key3] = arguments[_key3];
  }

  let [contract, params, tokenId] = _ref3;
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getClaimIneligibilityReasons(contractAddress, params, tokenId), () => {
    var _contract$drop7, _contract$drop7$claim, _contract$drop9, _contract$drop9$claim;

    invariant(contract, "No Contract instance provided");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop7 = contract.drop) === null || _contract$drop7 === void 0 ? void 0 : (_contract$drop7$claim = _contract$drop7.claim) === null || _contract$drop7$claim === void 0 ? void 0 : _contract$drop7$claim.conditions.getClaimIneligibilityReasons, "Contract instance does not support claimConditions.getClaimIneligibilityReasons");

    if (contract.featureName === "ERC1155") {
      var _contract$drop8, _contract$drop8$claim;

      invariant(tokenId, "tokenId is required for ERC1155 claim ineligibility reasons");
      return contract === null || contract === void 0 ? void 0 : (_contract$drop8 = contract.drop) === null || _contract$drop8 === void 0 ? void 0 : (_contract$drop8$claim = _contract$drop8.claim) === null || _contract$drop8$claim === void 0 ? void 0 : _contract$drop8$claim.conditions.getClaimIneligibilityReasons(tokenId, params.quantity, params.walletAddress);
    }

    return contract === null || contract === void 0 ? void 0 : (_contract$drop9 = contract.drop) === null || _contract$drop9 === void 0 ? void 0 : (_contract$drop9$claim = _contract$drop9.claim) === null || _contract$drop9$claim === void 0 ? void 0 : _contract$drop9$claim.conditions.getClaimIneligibilityReasons(params.quantity, params.walletAddress);
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => contract has to still be provided
    // 3. has a params object been passed?
    // 4. does params have an address in it?
    enabled: ((contract === null || contract === void 0 ? void 0 : contract.featureName) === "ERC1155" ? tokenId !== undefined : !!contract) && !!params && !!params.walletAddress
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to set claim conditions on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: setClaimConditions,
 *     isLoading,
 *     error,
 *   } = useSetClaimConditions(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to set claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => setClaimConditions({ phases: [{ price: 2, maxQuantity: 100 }] })}
 *     >
 *       Set Claim Conditions!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: setClaimConditions,
 *     isLoading,
 *     error,
 *   } = useSetClaimConditions(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to set claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => setClaimConditions({ phases: [{ price: 2, maxQuantity: 100 }] })}
 *     >
 *       Set Claim Conditions!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to set claim conditions
 * @beta
 */

function useSetClaimConditions() {
  for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    _ref4[_key4] = arguments[_key4];
  }

  let [contract, tokenId] = _ref4;
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async data => {
    var _contract$drop11, _contract$drop11$clai;

    invariant(contract, "No Contract instance provided");
    const {
      phases,
      reset = false
    } = data;
    invariant(phases, 'No "phases" provided');

    if (contract.featureName === "ERC1155") {
      var _contract$drop10, _contract$drop10$clai;

      invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return contract === null || contract === void 0 ? void 0 : (_contract$drop10 = contract.drop) === null || _contract$drop10 === void 0 ? void 0 : (_contract$drop10$clai = _contract$drop10.claim) === null || _contract$drop10$clai === void 0 ? void 0 : _contract$drop10$clai.conditions.set(tokenId, phases, reset);
    }

    return contract === null || contract === void 0 ? void 0 : (_contract$drop11 = contract.drop) === null || _contract$drop11 === void 0 ? void 0 : (_contract$drop11$clai = _contract$drop11.claim) === null || _contract$drop11$clai === void 0 ? void 0 : _contract$drop11$clai.conditions.set(phases, reset);
  }, {
    onSettled: () => {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to reset claim conditions on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: resetClaimConditions,
 *     isLoading,
 *     error,
 *   } = useResetClaimConditions(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to reset claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={resetClaimConditions}
 *     >
 *       Reset Claim Conditions
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: resetClaimConditions,
 *     isLoading,
 *     error,
 *   } = useResetClaimConditions(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to reset claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={resetClaimConditions}
 *     >
 *       Reset Claim Conditions
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to reset claim conditions
 * @beta
 */

function useResetClaimConditions() {
  for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    _ref5[_key5] = arguments[_key5];
  }

  let [contract, tokenId] = _ref5;
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async () => {
    var _contract$drop14, _contract$drop14$clai, _contract$drop15, _contract$drop15$clai;

    invariant(contract, "No Contract instance provided");

    const cleanConditions = conditions => {
      return conditions.map(c => ({ ...c,
        price: c.currencyMetadata.displayValue,
        maxQuantity: c.maxQuantity.toString(),
        quantityLimitPerTransaction: c.quantityLimitPerTransaction.toString()
      }));
    };

    if (contract.featureName === "ERC1155") {
      var _contract$drop12, _contract$drop12$clai, _contract$drop13, _contract$drop13$clai;

      invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      const claimConditions = await (contract === null || contract === void 0 ? void 0 : (_contract$drop12 = contract.drop) === null || _contract$drop12 === void 0 ? void 0 : (_contract$drop12$clai = _contract$drop12.claim) === null || _contract$drop12$clai === void 0 ? void 0 : _contract$drop12$clai.conditions.getAll(tokenId));
      return contract === null || contract === void 0 ? void 0 : (_contract$drop13 = contract.drop) === null || _contract$drop13 === void 0 ? void 0 : (_contract$drop13$clai = _contract$drop13.claim) === null || _contract$drop13$clai === void 0 ? void 0 : _contract$drop13$clai.conditions.set(tokenId, cleanConditions(claimConditions || []), true);
    }

    const claimConditions = await (contract === null || contract === void 0 ? void 0 : (_contract$drop14 = contract.drop) === null || _contract$drop14 === void 0 ? void 0 : (_contract$drop14$clai = _contract$drop14.claim) === null || _contract$drop14$clai === void 0 ? void 0 : _contract$drop14$clai.conditions.getAll());
    return await (contract === null || contract === void 0 ? void 0 : (_contract$drop15 = contract.drop) === null || _contract$drop15 === void 0 ? void 0 : (_contract$drop15$clai = _contract$drop15.claim) === null || _contract$drop15$clai === void 0 ? void 0 : _contract$drop15$clai.conditions.set(cleanConditions(claimConditions || []), true));
  }, {
    onSettled: () => {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

/**
 * A hook to get the native or (optional) ERC20 token balance of the connected wallet.
 *
 * @param tokenAddress - the address of the token contract, if empty will use the chain's native token
 * @returns the balance of the connected wallet (native or ERC20)
 * @beta
 */

function useBalance(tokenAddress) {
  const {
    rpcUrlMap
  } = useThirdwebConfigContext();
  const chainId = useChainId();
  const signer = useSigner();
  const walletAddress = useAddress();
  const walletSDK = useMemo(() => {
    if (signer) {
      const rpcUrl = rpcUrlMap[chainId];
      return new UserWallet(signer, {
        readonlySettings: rpcUrl ? {
          rpcUrl,
          chainId
        } : undefined
      });
    }

    return undefined;
  }, [signer, chainId]);
  const cacheKey = useMemo(() => {
    return cacheKeys.wallet.balance(chainId, walletAddress, tokenAddress);
  }, [chainId, tokenAddress, walletAddress]);
  return useQuery(cacheKey, () => {
    return walletSDK === null || walletSDK === void 0 ? void 0 : walletSDK.balance(tokenAddress);
  }, {
    // if user is not logged in no reason to try to fetch
    enabled: !!walletSDK && !!walletAddress,
    retry: true,
    keepPreviousData: false
  });
}

/**
 *
 * @example
 * ```jsx
 * const { data: recipient, isLoading, error } = usePrimarySalesRecipient(SmartContract);
 * ```
 *
 * Use this to get the primary sales recipient of your {@link SmartContract}
 * @param contract - an instance of a {@link SmartContract}
 * @returns the wallet address of the primary sales recipient
 * @beta
 */

function usePrimarySaleRecipient(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.sales.getRecipient(contractAddress), () => {
    invariant(contract, "No contract provided");
    invariant("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.getRecipient();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the primary sales recipient of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updatePrimarySalesRecipient,
 *     isLoading,
 *     error,
 *   } = useUpdatePrimarySaleRecipient(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update recipient", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updatePrimarySalesRecipient({ newRecipient: "0x123" })}
 *     >
 *       Update Recipient
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the primary sales recipient
 * @beta
 */

function useUpdatePrimarySaleRecipient(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const activeChainId = useActiveChainId();
  return useMutation(newRecipient => {
    invariant(contract, "No contract provided");
    invariant("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.setRecipient(newRecipient);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
} // end prinary sales
// royalties

/**
 * Use this to get the royalty settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: settings, isLoading, error } = useRoyaltySettings(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns an object containing recipient address and the royalty basis points
 * @beta
 */

function useRoyaltySettings(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.royalties.getDefaultRoyaltyInfo(contractAddress), () => {
    invariant(contract, "No contract provided");
    invariant("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.getDefaultRoyaltyInfo();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the royalty settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updateRoyaltySettings,
 *     isLoading,
 *     error,
 *   } = useUpdateRoyaltySettings(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update royalty settings", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updateRoyaltySettings({ updatePayload: { fee_recipient: "0x123", seller_fee_basis_points: 5_00 } })}
 *     >
 *       Update Royalty Settings
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the royalty settings
 * @beta
 */

function useUpdateRoyaltySettings(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const activeChainId = useActiveChainId();
  return useMutation(updatePayload => {
    invariant(contract, "No contract provided");
    invariant("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.setDefaultRoyaltyInfo(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
} // end royalties
// platformFees

/**
 * Use this to get the platform fees settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: platformFees, isLoading, error } = usePlatformFees(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns an object containing the platform fee basis points and the fee recipient address
 * @beta
 */

function usePlatformFees(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.platformFees.get(contractAddress), () => {
    invariant(contract, "No contract provided");
    invariant("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the platform fees settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updatePlatformFees,
 *     isLoading,
 *     error,
 *   } = useUpdatePlatformFees(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update platform fees", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updatePlatformFees({ updatePayload: { fee_recipient: "0x123", platform_fee_basis_points: 5_00 } })}
 *     >
 *       Update Platform fees
 *     </button>
 *   );
 * };
 * ```
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the platform fees settings
 * @beta
 */

function useUpdatePlatformFees(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const activeChainId = useActiveChainId();
  return useMutation(updatePayload => {
    invariant(contract, "No contract provided");
    invariant("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.set(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
} // end platformFees
// metadata

/**
 * Use this to get the metadata of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: metadata, isLoading, error } = useMetadata(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a {@link CustomContractMetadata} object containing the metadata
 * @beta
 */

function useMetadata(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.metadata.get(contractAddress), () => {
    invariant(contract, "No contract provided");
    invariant("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the metadata of your {@link SmartContract}
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updateMetadata,
 *     isLoading,
 *     error,
 *   } = useUpdateMetadata(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update metadata", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updateMetadata({ updatePayload: { name: "My Contract", description: "This is my contract" } })}
 *     >
 *       Update Metadata
 *     </button>
 *   );
 * };
 * ```
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the metadata
 * @beta
 */

function useUpdateMetadata(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const activeChainId = useActiveChainId();
  return useMutation(updatePayload => {
    invariant(contract, "No contract provided");
    invariant("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.update(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
} // end metadata

/** **********************/

/**         UTILS       **/

/** **********************/

/**
 * @internal
 */

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get the roles of a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: roles, isLoading, error } = useAllRoleMembers(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a list of addresses for all supported roles on the contract.
 * @beta
 */
function useAllRoleMembers(contract) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.getAll(contractAddress), () => {
    invariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles"); // have to cast to any because of role bs, type is defined in the useQueryWithNetwork definition above

    return contract.roles.getAll();
  }, {
    enabled: !!contract && !!contractAddress
  });
}
/**
 * Use this to get the members of a role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: members, isLoading, error } = useRoleMembers(SmartContract, "admin");
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @param role - the role to get the members of, see {@link Role}
 * @returns a list of addresses that are members of the role
 * @beta
 */

function useRoleMembers(contract, role) {
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.get(contractAddress, role), () => {
    invariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    return contract.roles.get(role);
  }, {
    enabled: !!contract && !!contractAddress && !!role
  });
}
/**
 * Use this to check if a {@link WalletAddress} is a member of a role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: isMember, isLoading, error } = useIsAddressRole(SmartContract, "admin", "0x123");
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @param role - the role to check the member against, see {@link Role}
 * @param walletAddress - the address to check
 * @returns true if the address is a member of the role, or false if not
 * @beta
 */

function useIsAddressRole(contract, role, walletAddress) {
  // TODO this might be possible to do with `verify` fn instead?
  const contractHasRoles = !!(contract && contract.roles);
  const {
    data
  } = useRoleMembers(contractHasRoles ? contract : undefined, role); // if the contract does not have roles then everything is allowed === true

  if (contractHasRoles === false) {
    return true;
  } // switch logic (if address 0 is in the role list then anyone has permissions to it)


  if (data !== null && data !== void 0 && data.includes(constants.AddressZero)) {
    return true;
  } // actual role check logic


  return !!(walletAddress && data !== null && data !== void 0 && data.includes(walletAddress));
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to OVERWRITE the list of addresses that are members of specific roles
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: overwriteRoles,
 *     isLoading,
 *     error,
 *   } = useSetAllRoleMembers(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to overwrite roles", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => overwriteRoles({  rolesWithAddresses: { minter: [] } })}
 *     >
 *       Overwrite Roles
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to overwrite all roles on the contract
 * @beta
 */

function useSetAllRoleMembers(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async rolesWithAddresses => {
    invariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    await contract.roles.setAll(rolesWithAddresses);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
} // const { mutate } = useSetAllRoleMembers(undefined as unknown as NFTCollection);

/**
 * Use this to grant a {@link WalletAddress} a specific role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: grantRole,
 *     isLoading,
 *     error,
 *   } = useGrantRole(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to grant role", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => grantRole({  role: "admin", address: "0x123" })}
 *     >
 *       Grant Role
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to grant a member of a role on the contract
 * @beta
 */

function useGrantRole(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async params => {
    invariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    await contract.roles.grant(params.role, params.address);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
/**
 * Use this to revoke a {@link WalletAddress} a specific role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: revokeRole,
 *     isLoading,
 *     error,
 *   } = useRevokeRole(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to revoke role", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => revokeRole({  role: "admin", address: "0x123" })}
 *     >
 *       Revoke Role
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to revoke a role from a member on the contract
 * @beta
 */

function useRevokeRole(contract) {
  const activeChainId = useActiveChainId();
  const contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async params => {
    invariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    await contract.roles.revoke(params.role, params.address);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}

const DEFAULT_IPFS_GATEWAY = "https://gateway.ipfscdn.io/ipfs/";
const DEFAULT_IPFS_RESOLVER_OPTIONS = {
  gatewayUrl: DEFAULT_IPFS_GATEWAY
};

function resolveIpfsUri(uri) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_IPFS_RESOLVER_OPTIONS;

  if (!uri) {
    return undefined;
  }

  if (uri.startsWith("ipfs://")) {
    return uri.replace("ipfs://", options.gatewayUrl);
  }

  return uri;
}
async function resolveMimeType(url) {
  if (!url) {
    return undefined;
  }

  const mimeType = mime.getType(url);

  if (mimeType) {
    return mimeType;
  }

  const res = await fetch(url, {
    method: "HEAD"
  });

  if (res.ok && res.headers.has("content-type")) {
    var _res$headers$get;

    return (_res$headers$get = res.headers.get("content-type")) !== null && _res$headers$get !== void 0 ? _res$headers$get : undefined;
  } // we failed to resolve the mime type, return null


  return undefined;
}

let video;

function supportsVideoType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("video/")) {
    return "";
  }

  if (!video) {
    video = document.createElement("video");
  }

  return video.canPlayType(mimeType);
}

function shouldRenderVideoTag(mimeType) {
  return !!supportsVideoType(mimeType);
}
let audio;

function supportsAudioType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("audio/")) {
    return "";
  }

  if (!audio) {
    audio = document.createElement("audio");
  }

  return audio.canPlayType(mimeType);
}

function shouldRenderAudioTag(mimeType) {
  return !!supportsAudioType(mimeType);
}

function mergeRefs(refs) {
  return value => {
    refs.forEach(ref => {
      if (typeof ref === "function") {
        ref(value); // eslint-disable-next-line eqeqeq
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

const CarbonDocumentUnknown = props => {
  return /*#__PURE__*/jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/*#__PURE__*/jsx("circle", {
      cx: "9",
      cy: "28.5",
      r: "1.5",
      fill: "currentColor"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z"
    })]
  });
};
const CarbonDocumentAudio = props => {
  return /*#__PURE__*/jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z"
    })]
  });
};
const CarbonPauseFilled = props => {
  return /*#__PURE__*/jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z"
    })
  });
};
const CarbonPlayFilledAlt = props => {
  return /*#__PURE__*/jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z"
    })
  });
};

/* eslint-disable @next/next/no-img-element */

const PlayButton = _ref => {
  let {
    onClick,
    isPlaying
  } = _ref;
  const [isHovering, setIsHovering] = useState(false);

  const onMouseEnter = () => setIsHovering(true);

  const onMouseLeave = () => setIsHovering(false);

  const onMouseDown = () => setIsHovering(false);

  const onMouseUp = () => setIsHovering(true);

  return /*#__PURE__*/jsx("button", {
    style: {
      position: "absolute",
      bottom: 0,
      right: 0,
      transform: "translate(-25%, -25%)",
      maxWidth: "32px",
      width: "8%",
      minWidth: "24px",
      aspectRatio: "1",
      zIndex: 3,
      backgroundColor: "#fff",
      color: "rgb(138, 147, 155)",
      display: "grid",
      placeItems: "center",
      borderRadius: "50%",
      border: "1px solid rgb(229, 232, 235)",
      cursor: "pointer",
      ...(isHovering ? {
        color: "rgb(53, 56, 64)",
        boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px"
      } : {})
    },
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    children: !isPlaying ? /*#__PURE__*/jsx(CarbonPlayFilledAlt, {
      style: {
        width: "66%",
        height: "66%"
      }
    }) : /*#__PURE__*/jsx(CarbonPauseFilled, {
      style: {
        width: "66%",
        height: "66%"
      }
    })
  });
};

const VideoPlayer = /*#__PURE__*/React.forwardRef((_ref2, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    children,
    style,
    width,
    height,
    controls,
    ...restProps
  } = _ref2;
  const videoRef = useRef(null);
  const [playing, setPlaying] = useState(!requireInteraction);
  const [muted, setMuted] = useState(true);
  useEffect(() => {
    if (videoRef.current) {
      if (playing) {
        try {
          videoRef.current.play();
        } catch (err) {
          console.error("error playing video", err);
        }
      } else {
        try {
          videoRef.current.pause();
          videoRef.current.currentTime = 0;
        } catch (err) {
          console.error("error pausing video", err);
        }
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [/*#__PURE__*/jsx("video", {
      ref: mergeRefs([videoRef, ref]),
      src: src !== null && src !== void 0 ? src : undefined,
      poster: poster !== null && poster !== void 0 ? poster : undefined,
      loop: true,
      playsInline: true,
      controlsList: "nodownload",
      muted: muted,
      preload: poster ? "metadata" : "auto",
      onCanPlay: () => {
        if (playing) {
          var _videoRef$current;

          (_videoRef$current = videoRef.current) === null || _videoRef$current === void 0 ? void 0 : _videoRef$current.play();
        }
      },
      width: width,
      height: height,
      controls: controls,
      style: {
        height: "100%",
        width: "100%",
        objectFit: "contain",
        zIndex: 1,
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt: alt
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
        setMuted(false);
      },
      isPlaying: playing
    })]
  });
});
VideoPlayer.displayName = "VideoPlayer";
const AudioPlayer = /*#__PURE__*/React.forwardRef((_ref3, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    children,
    style,
    height,
    width,
    controls,
    ...restProps
  } = _ref3;
  const audioRef = useRef(null);
  const [playing, setPlaying] = useState(false);
  const [muted, setMuted] = useState(true);
  useEffect(() => {
    if (audioRef.current) {
      if (playing) {
        audioRef.current.play();
      } else {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [poster ? /*#__PURE__*/jsx("img", {
      height: height,
      width: width,
      src: poster,
      style: {
        height: "100%",
        width: "100%",
        pointerEvents: "none",
        objectFit: "contain"
      },
      alt: alt
    }) : /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        pointerEvents: "none",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsx(CarbonDocumentAudio, {
        style: {
          height: "64px",
          width: "64px"
        }
      })
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
        setMuted(false);
      },
      isPlaying: playing
    }), /*#__PURE__*/jsx("audio", {
      ref: mergeRefs([audioRef, ref]),
      src: src !== null && src !== void 0 ? src : undefined,
      loop: true,
      playsInline: true,
      muted: muted,
      preload: "none",
      controlsList: "nodownload",
      style: {
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        zIndex: -1,
        visibility: "hidden"
      }
    })]
  });
});
AudioPlayer.displayName = "AudioPlayer";
const IframePlayer = /*#__PURE__*/React.forwardRef((_ref4, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    children,
    style,
    height,
    width,
    controls,
    ...restProps
  } = _ref4;
  const {
    observe,
    width: elWidth
  } = useDimensions();
  const [playing, setPlaying] = useState(!requireInteraction);

  if (elWidth < 300) {
    return /*#__PURE__*/jsx("div", {
      ref: observe,
      children: /*#__PURE__*/jsx(LinkPlayer, {
        style: style,
        src: src,
        alt: alt,
        ...restProps
      })
    });
  }

  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    ref: observe,
    children: [/*#__PURE__*/jsx("iframe", {
      src: playing ? src !== null && src !== void 0 ? src : undefined : undefined,
      ref: ref,
      style: {
        objectFit: "contain",
        zIndex: 1,
        height: "100%",
        width: "100%",
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      },
      sandbox: "allow-scripts",
      allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt: alt
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
      },
      isPlaying: playing
    })]
  });
});
IframePlayer.displayName = "IframePlayer";
const LinkPlayer = /*#__PURE__*/React.forwardRef((_ref5, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    children,
    style,
    height,
    width,
    controls,
    ...restProps
  } = _ref5;
  return /*#__PURE__*/jsx("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap"
        },
        children: [/*#__PURE__*/jsx(CarbonDocumentUnknown, {
          style: {
            maxWidth: "128px",
            minWidth: "48px",
            width: "50%",
            aspectRatio: "1"
          }
        }), /*#__PURE__*/jsx("a", {
          rel: "noopener noreferrer",
          style: {
            textDecoration: "underline",
            color: "rgb(138, 147, 155)"
          },
          href: src !== null && src !== void 0 ? src : undefined,
          target: "_blank",
          ref: ref,
          children: alt || "File"
        })]
      })
    })
  });
});
LinkPlayer.displayName = "LinkPlayer";
/**
 * This component can be used to render any media type, including image, audio, video, and html files.
 * Its convenient for rendering NFT media files, as these can be a variety of different types.
 * The component falls back to a external link if the media type is not supported.
 *
 * Props: {@link MediaRendererProps}
 *
 * @example
 * We can take a video file hosted on IPFS and render it using this component as follows
 * ```jsx
 * const Component = () => {
 *   return <MediaRenderer
 *     src="ipfs://Qmb9ZV5yznE4C4YvyJe8DVFv1LSVkebdekY6HjLVaKmHZi"
 *     alt="A mp4 video"
 *   />
 * }
 * ```
 *
 * You can try switching out the `src` prop to different types of URLs and media types to explore the possibilities.
 */

const MediaRenderer = /*#__PURE__*/React.forwardRef((_ref6, ref) => {
  let {
    children,
    src,
    poster,
    alt,
    requireInteraction = false,
    style,
    ...restProps
  } = _ref6;
  const mergedStyle = {
    objectFit: "contain",
    ...style
  };
  const videoOrImageSrc = useResolvedMediaType(src !== null && src !== void 0 ? src : undefined);
  const possiblePosterSrc = useResolvedMediaType(poster !== null && poster !== void 0 ? poster : undefined);

  if (!videoOrImageSrc.mimeType) {
    return /*#__PURE__*/jsx("img", {
      style: mergedStyle,
      ...restProps,
      ref: ref,
      alt: alt
    });
  } else if (videoOrImageSrc.mimeType === "text/html") {
    return /*#__PURE__*/jsx(IframePlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(VideoPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(AudioPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("image/")) {
    return /*#__PURE__*/jsx("img", {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      alt: alt,
      ref: ref,
      ...restProps
    });
  }

  return /*#__PURE__*/jsx(LinkPlayer, {
    style: mergedStyle,
    src: videoOrImageSrc.url,
    alt: alt,
    ref: ref,
    ...restProps
  });
});
MediaRenderer.displayName = "MediaRenderer";

/**
 * @param uri - the uri to resolve (can be a url or a ipfs://\<cid\>)
 * @returns the fully resolved url + mime type of the media
 *
 * @example
 * Usage with fully formed url:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("https://example.com/video.mp4");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 *
 * Usage with ipfs cid:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("ipfs://QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvsd");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 */
function useResolvedMediaType(uri) {
  const resolvedUrl = useMemo(() => resolveIpfsUri(uri), [uri]);
  const resolvedMimType = useQuery(["mime-type", resolvedUrl], () => resolveMimeType(resolvedUrl), {
    enabled: !!resolvedUrl
  });
  return {
    url: resolvedUrl,
    mimeType: resolvedMimType.data
  };
}

/**
 *
 * @example
 * ```jsx
 * import { ThirdwebNftMedia, useNFTCollection, useNFT } from "@thirdweb-dev/react";
 * export default function NFTCollectionRender() {
 *   const contract = useNFTCollection(<your-contract-address>);
 *   const { data: nft, isLoading } = useNFT(contract, 0);
 *
 *   return (
 *     <div>
 *       {!isLoading && nft ? (
 *         <ThirdwebNftMedia metadata={nft.metadata} />
 *       ) : (
 *         <p>Loading...</p>
 *       )}
 *     </div>
 *   );
 * }
 * ```
 *
 * Use this to get the primary sales recipient of your {@link SmartContract}
 * @param contract - an instance of a {@link SmartContract}
 * @returns the wallet address of the primary sales recipient
 * @beta
 */
const ThirdwebNftMedia = /*#__PURE__*/React.forwardRef((_ref, ref) => {
  var _metadata$name;

  let {
    metadata,
    ...props
  } = _ref;
  return /*#__PURE__*/jsx(MediaRenderer, {
    src: metadata.animation_url || metadata.image,
    poster: metadata.image,
    alt: ((_metadata$name = metadata.name) === null || _metadata$name === void 0 ? void 0 : _metadata$name.toString()) || "",
    ref: ref,
    ...props
  });
});

/**
 * Forces a re-render, similar to `forceUpdate` in class components.
 */


function useForceUpdate() {
  const [, dispatch] = useState(Object.create(null));
  return useCallback(() => {
    dispatch(Object.create(null));
  }, []);
}
/**
 * Portal from `@reach/portal`
 *
 * @see Docs https://reach.tech/portal#portal
 */

const PortalImpl = _ref => {
  let {
    children,
    type = "reach-portal",
    containerRef
  } = _ref;
  const mountNode = useRef(null);
  const portalNode = useRef(null);
  const forceUpdate = useForceUpdate();
  useLayoutEffect(() => {
    // This ref may be null when a hot-loader replaces components on the page
    if (!mountNode.current) {
      return;
    } // It's possible that the content of the portal has, itself, been portaled.
    // In that case, it's important to append to the correct document element.


    const ownerDocument = mountNode.current.ownerDocument;
    const body = (containerRef === null || containerRef === void 0 ? void 0 : containerRef.current) || ownerDocument.body;
    portalNode.current = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.createElement(type);
    body.appendChild(portalNode.current);
    forceUpdate();
    return () => {
      if (portalNode.current && body) {
        body.removeChild(portalNode.current);
      }
    };
  }, [type, forceUpdate, containerRef]);
  return portalNode.current ? /*#__PURE__*/createPortal(children, portalNode.current) : /*#__PURE__*/jsx("span", {
    ref: mountNode
  });
};

const Portal = _ref2 => {
  let {
    unstable_skipInitialRender,
    ...props
  } = _ref2;
  const [hydrated, setHydrated] = useState(false);
  useEffect(() => {
    if (unstable_skipInitialRender) {
      setHydrated(true);
    }
  }, [unstable_skipInitialRender]);

  if (unstable_skipInitialRender && !hydrated) {
    return null;
  }

  return /*#__PURE__*/jsx(PortalImpl, { ...props
  });
};
Portal.displayName = "Portal";

function shortenString(str, extraShort) {
  return "".concat(str.substring(0, extraShort ? 4 : 6), "...").concat(str.substring(str.length - (extraShort ? 3 : 4)));
}
function shortenAddress(address, extraShort) {
  try {
    const formattedAddress = utils.getAddress(address);
    return shortenString(formattedAddress, extraShort);
  } catch {
    return address;
  }
}
function shortenIfAddress(address, extraShort) {
  if (typeof address === "string" && address.length > 0) {
    return shortenAddress(address, extraShort);
  }

  return address || "";
}

// extracted from chakra-ui

/**
 * React hook to copy content to clipboard
 *
 */
function useClipboard(text) {
  let optionsOrTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const [hasCopied, setHasCopied] = useState(false);
  const {
    timeout = 1500,
    ...copyOptions
  } = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout;
  const onCopy = useCallback(() => {
    const didCopy = copy(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  useEffect(() => {
    let timeoutId = null;

    if (hasCopied) {
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    }

    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy,
    hasCopied
  };
}

function useIsMounted() {
  const [isMounted, setIsMounted] = useState(false);
  useEffect(() => {
    setIsMounted(true);
  });
  return isMounted;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var _templateObject$6;
const Box = styled.div(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral([""])));

var _templateObject$5;
const spin = keyframes({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
const Spinner = styled.div(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral(["\n  display: inline-block;\n  border-top: 2px solid currentcolor;\n  border-right: 2px solid currentcolor;\n  border-bottom-style: solid;\n  border-left-style: solid;\n  border-radius: 99999px;\n  border-bottom-width: 2px;\n  border-left-width: 2px;\n  border-bottom-color: transparent;\n  border-left-color: transparent;\n  animation: 0.45s linear 0s infinite normal none running ", ";\n  width: 0.75em;\n  height: 0.75em;\n  flex-shrink: 0;\n"])), spin);

var _templateObject$4, _templateObject2, _templateObject3;
const BaseButton = styled.button(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral(["\n  position: relative;\n  border-radius: 0.5em;\n  padding: 0.75em 1.25em;\n  padding-right: ", ";\n  padding-left: ", ";\n  font-size: 1em;\n  font-weight: 600;\n  letter-spacing: 0.5px;\n  display: flex;\n  gap: 0.5em;\n  align-items: center;\n  justify-content: space-evenly;\n  color: ", ";\n  border: 2px solid\n    ", ";\n  &:hover {\n    cursor: pointer;\n  }\n  &:disabled {\n    cursor: not-allowed;\n  }\n  &:focus {\n    outline: 2px solid ", ";\n    outline-offset: 1px;\n  }\n"])), props => props.hasRightElement ? "0.75em" : "1.25em", props => props.hasLeftElement ? "0.75em" : "1.25em", props => computeTextColorBasedOnBackground(props.theme.colors.accent), props => computeHoverColor(props.theme.colors.accent), props => props.theme.colors.accent);

function computeHoverColor(c) {
  const col = color(c);

  if (col.hex() === "#000000") {
    return "#262627";
  }

  if (col.luminosity() < 0.2) {
    return col.lighten(0.1).hex();
  }

  return col.darken(0.1).hex();
}

function computeDisabledColor(c) {
  const col = color(c);

  if (col.hex() === "#000000") {
    return "#262627";
  }

  if (col.luminosity() < 0.2) {
    return col.lighten(0.5).hex();
  }

  return col.darken(0.5).hex();
}

function computeTextColorBasedOnBackground(c) {
  const col = color(c);

  if (col.isDark()) {
    return "#fff";
  }

  return "#000";
}

const SolidButton = styled(BaseButton)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  background: ", ";\n  &:hover {\n    background: ", ";\n    border-color: ", ";\n  }\n  &:disabled {\n    background: ", ";\n    border-color: ", ";\n    color: ", ";\n  }\n"])), props => props.theme.colors.accent, props => computeHoverColor(props.theme.colors.accent), props => computeHoverColor(props.theme.colors.accent), props => computeDisabledColor(props.theme.colors.accent), props => computeDisabledColor(props.theme.colors.accent), props => computeTextColorBasedOnBackground(computeDisabledColor(props.theme.colors.accent)));
const OutlineButton = styled(BaseButton)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  background: transparent;\n  &:hover {\n    background: ", ";\n  }\n"])), props => color(props.theme.colors.background).alpha(0.5).hexa());
const Button = _ref => {
  let {
    children,
    variant,
    rightElement,
    leftElement,
    isLoading,
    isDisabled,
    disabled,
    ...restProps
  } = _ref;
  const Btn = variant === "outline" ? OutlineButton : SolidButton;
  return /*#__PURE__*/jsxs(Btn, { ...restProps,
    disabled: isDisabled || disabled || isLoading,
    hasRightElement: !!rightElement,
    hasLeftElement: !!leftElement,
    children: [isLoading ? /*#__PURE__*/jsx(Spinner, {
      style: {
        position: "absolute",
        left: "calc(50% - 0.75em / 2)"
      }
    }) : null, /*#__PURE__*/jsxs("span", {
      style: {
        opacity: isLoading ? 0 : 1,
        display: "inherit",
        gap: "inherit",
        alignItems: "inherit",
        justifyContent: "inherit",
        width: "100%"
      },
      children: [leftElement, children, rightElement]
    })]
  });
};

const chainLogos = {
  ethereum: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("path", {
        fill: "#25292E",
        fillRule: "evenodd",
        d: "M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z",
        clipRule: "evenodd"
      }), /*#__PURE__*/jsx("path", {
        fill: "url(#a)",
        fillOpacity: ".3",
        fillRule: "evenodd",
        d: "M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z",
        clipRule: "evenodd"
      }), /*#__PURE__*/jsx("path", {
        fill: "url(#b)",
        d: "M8.19 14.77 14 18.21l5.8-3.44-5.8 8.19-5.81-8.19Z"
      }), /*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "m14 16.93-5.81-3.44L14 4.34l5.81 9.15L14 16.93Z"
      }), /*#__PURE__*/jsxs("defs", {
        children: [/*#__PURE__*/jsxs("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        }), /*#__PURE__*/jsxs("linearGradient", {
          id: "b",
          x1: "14",
          x2: "14",
          y1: "14.77",
          y2: "22.96",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: ".9"
          })]
        })]
      })]
    })
  },
  arbitrum: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("rect", {
        width: "26.6",
        height: "26.6",
        x: ".7",
        y: ".7",
        fill: "#2D374B",
        stroke: "#96BEDC",
        strokeWidth: "1.4",
        rx: "13.3"
      }), /*#__PURE__*/jsx("mask", {
        id: "a",
        width: "28",
        height: "28",
        x: "0",
        y: "0",
        maskUnits: "userSpaceOnUse",
        style: {
          maskType: "alpha"
        },
        children: /*#__PURE__*/jsx("rect", {
          width: "28",
          height: "28",
          fill: "#C4C4C4",
          rx: "14"
        })
      }), /*#__PURE__*/jsxs("g", {
        mask: "url(#a)",
        children: [/*#__PURE__*/jsx("path", {
          fill: "#28A0F0",
          d: "m14.0861 18.6041 6.5014 10.2239 4.0057-2.3213-7.86-12.3943-2.6471 4.4917Zm13.0744 3.4692-.003-1.8599-7.3064-11.407-2.3087 3.9173 7.091 11.4303 2.172-1.2586a.9628.9628 0 0 0 .3555-.7009l-.0004-.1212Z"
        }), /*#__PURE__*/jsx("rect", {
          width: "25.9",
          height: "25.9",
          x: "1.05",
          y: "1.05",
          fill: "url(#b)",
          fillOpacity: ".3",
          stroke: "#96BEDC",
          strokeWidth: "2.1",
          rx: "12.95"
        }), /*#__PURE__*/jsx("path", {
          fill: "#fff",
          d: "m.3634 28.2207-3.07-1.7674-.234-.8333L7.7461 9.0194c.7298-1.1913 2.3197-1.575 3.7957-1.5541l1.7323.0457L.3634 28.2207ZM19.1655 7.511l-4.5653.0166L2.24 27.9533l3.6103 2.0788.9818-1.6652L19.1655 7.511Z"
        })]
      }), /*#__PURE__*/jsx("defs", {
        children: /*#__PURE__*/jsxs("linearGradient", {
          id: "b",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  avalanche: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "M23 5H5v18h18V5Z"
      }), /*#__PURE__*/jsx("path", {
        fill: "#E84142",
        fillRule: "evenodd",
        d: "M14 28c-7.513.008-14-6.487-14-14C0 6.196 6.043-.008 14 0c7.95.008 14 6.196 14 14 0 7.505-6.495 13.992-14 14Zm-3.971-7.436H7.315c-.57 0-.851 0-1.023-.11a.69.69 0 0 1-.313-.54c-.01-.202.13-.45.412-.944l6.7-11.809c.285-.501.43-.752.612-.845.195-.1.429-.1.625 0 .182.093.326.344.611.845l1.377 2.404.007.013c.308.538.464.81.533 1.097a2.04 2.04 0 0 1 0 .954c-.07.289-.224.564-.536 1.11l-3.52 6.22-.009.017c-.31.542-.467.817-.684 1.024a2.048 2.048 0 0 1-.835.485c-.285.079-.604.079-1.243.079Zm6.852 0h3.888c.574 0 .862 0 1.034-.113a.687.687 0 0 0 .313-.543c.01-.196-.128-.434-.398-.9a8.198 8.198 0 0 1-.028-.048l-1.948-3.332-.022-.037c-.274-.463-.412-.697-.59-.787a.684.684 0 0 0-.621 0c-.179.093-.323.337-.608.828l-1.94 3.331-.007.012c-.284.49-.426.735-.416.936.014.22.127.423.313.543.168.11.456.11 1.03.11Z",
        clipRule: "evenodd"
      })]
    })
  },
  optimism: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "#FF3131",
        rx: "14"
      }), /*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "url(#a)",
        fillOpacity: ".3",
        rx: "14"
      }), /*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "M9.22 18.35c2.7 0 4.86-2.2 4.86-5.38 0-2.19-1.47-3.8-3.98-3.8-2.72 0-4.85 2.2-4.85 5.38 0 2.2 1.5 3.8 3.97 3.8Zm.83-7.35c1.06 0 1.74.81 1.74 2.1 0 1.9-1.11 3.42-2.51 3.42-1.06 0-1.74-.82-1.74-2.1 0-1.89 1.11-3.42 2.5-3.42Zm6.38-1.68-1.88 8.88h2.26l.55-2.6h1.47c2.43 0 4.01-1.38 4.01-3.6 0-1.61-1.17-2.68-3.1-2.68h-3.3Zm1.9 1.74h.94c.83 0 1.3.38 1.3 1.14 0 1-.68 1.7-1.74 1.7h-1.11l.6-2.84Z"
      }), /*#__PURE__*/jsx("defs", {
        children: /*#__PURE__*/jsxs("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  polygon: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "#8247E5",
        rx: "14"
      }), /*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "url(#a)",
        fillOpacity: ".3",
        rx: "14"
      }), /*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "M18.28 10.92a1.06 1.06 0 0 0-1.06 0l-2.41 1.42-1.65.93-2.41 1.43c-.31.19-.72.19-1.06 0l-1.92-1.12a1.07 1.07 0 0 1-.53-.9v-2.2a1 1 0 0 1 .53-.9l1.9-1.08c.3-.18.7-.18 1.04 0l1.9 1.09c.3.18.52.52.52.9v1.42l1.64-.96V9.52a1 1 0 0 0-.52-.9l-3.5-2.04a1.06 1.06 0 0 0-1.06 0L6.13 8.63a1 1 0 0 0-.53.9v4.12a1 1 0 0 0 .53.9l3.56 2.04c.31.19.71.19 1.06 0l2.41-1.4 1.65-.95 2.41-1.4c.31-.19.72-.19 1.06 0l1.89 1.09c.3.18.53.52.53.9v2.2a1 1 0 0 1-.53.9l-1.9 1.11c-.3.19-.7.19-1.05 0l-1.89-1.08a1.07 1.07 0 0 1-.52-.9v-1.43l-1.65.96v1.43a1 1 0 0 0 .53.9l3.56 2.04c.31.19.72.19 1.06 0l3.56-2.04c.31-.19.53-.53.53-.9v-4.13a1 1 0 0 0-.53-.9l-3.6-2.07Z"
      }), /*#__PURE__*/jsx("defs", {
        children: /*#__PURE__*/jsxs("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  fantom: {
    svgProps: {
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsxs("defs", {
        children: [/*#__PURE__*/jsx("style", {
          children: ".cls-1{fill:#fff;fill-rule:evenodd}"
        }), /*#__PURE__*/jsx("mask", {
          id: "mask",
          width: 93.1,
          height: 20,
          x: 10,
          y: 6,
          maskUnits: "userSpaceOnUse",
          children: /*#__PURE__*/jsx("path", {
            id: "a",
            d: "M10 6h93.1v20H10Z",
            className: "cls-1"
          })
        })]
      }), /*#__PURE__*/jsx("g", {
        id: "Layer_2",
        "data-name": "Layer 2",
        children: /*#__PURE__*/jsxs("g", {
          id: "Layer_1-2",
          "data-name": "Layer 1",
          children: [/*#__PURE__*/jsx("circle", {
            cx: 16,
            cy: 16,
            r: 16,
            fill: "#13b5ec"
          }), /*#__PURE__*/jsx("path", {
            d: "m17.2 12.9 3.6-2.1V15Zm3.6 9L16 24.7l-4.8-2.8V17l4.8 2.8 4.8-2.8Zm-9.6-11.1 3.6 2.1-3.6 2.1Zm5.4 3.1 3.6 2.1-3.6 2.1Zm-1.2 4.2L11.8 16l3.6-2.1Zm4.8-8.3L16 12.2l-4.2-2.4L16 7.3ZM10 9.4v13.1l6 3.4 6-3.4V9.4L16 6Z",
            className: "cls-1"
          })]
        })
      })]
    })
  },
  binance: {
    svgProps: {
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("polygon", {
        fill: "#F3BA2F",
        points: "38.171,53.203 62.759,28.616 87.36,53.216 101.667,38.909 62.759,0 23.864,38.896 "
      }), /*#__PURE__*/jsx("rect", {
        x: "3.644",
        y: "53.188",
        transform: "matrix(0.7071 0.7071 -0.7071 0.7071 48.7933 8.8106)",
        fill: "#F3BA2F",
        width: "20.233",
        height: "20.234"
      }), /*#__PURE__*/jsx("polygon", {
        fill: "#F3BA2F",
        points: "38.171,73.408 62.759,97.995 87.359,73.396 101.674,87.695 101.667,87.703 62.759,126.61123.863,87.716 23.843,87.696 "
      }), /*#__PURE__*/jsx("rect", {
        x: "101.64",
        y: "53.189",
        transform: "matrix(-0.7071 0.7071 -0.7071 -0.7071 235.5457 29.0503)",
        fill: "#F3BA2F",
        width: "20.234",
        height: "20.233"
      }), /*#__PURE__*/jsx("polygon", {
        fill: "#F3BA2F",
        points: "77.271,63.298 77.277,63.298 62.759,48.78 52.03,59.509 52.029,59.509 50.797,60.742 48.254,63.28548.254,63.285 48.234,63.305 48.254,63.326 62.759,77.831 77.277,63.313 77.284,63.305 "
      })]
    })
  }
};

const CoinbaseWalletIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("rect", {
      width: "28",
      height: "28",
      fill: "#2C5FF6"
    }), /*#__PURE__*/jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M14 23.8C19.4124 23.8 23.8 19.4124 23.8 14C23.8 8.58761 19.4124 4.2 14 4.2C8.58761 4.2 4.2 8.58761 4.2 14C4.2 19.4124 8.58761 23.8 14 23.8ZM11.55 10.8C11.1358 10.8 10.8 11.1358 10.8 11.55V16.45C10.8 16.8642 11.1358 17.2 11.55 17.2H16.45C16.8642 17.2 17.2 16.8642 17.2 16.45V11.55C17.2 11.1358 16.8642 10.8 16.45 10.8H11.55Z",
      fill: "white"
    })]
  })
};

const MetamaskIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("rect", {
      width: "28",
      height: "28",
      fill: "white"
    }), /*#__PURE__*/jsx("path", {
      d: "M24.0891 3.1199L15.3446 9.61456L16.9617 5.7828L24.0891 3.1199Z",
      fill: "#E2761B",
      stroke: "#E2761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M3.90207 3.1199L12.5763 9.67608L11.0383 5.7828L3.90207 3.1199Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M20.9429 18.1745L18.6139 21.7426L23.597 23.1136L25.0295 18.2536L20.9429 18.1745Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M2.97929 18.2536L4.40301 23.1136L9.38607 21.7426L7.05713 18.1745L2.97929 18.2536Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.10483 12.1456L7.71626 14.2461L12.6642 14.4658L12.4884 9.14877L9.10483 12.1456Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.8864 12.1456L15.4589 9.08725L15.3446 14.4658L20.2837 14.2461L18.8864 12.1456Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.38606 21.7426L12.3566 20.2925L9.79033 18.2888L9.38606 21.7426Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.6347 20.2925L18.6139 21.7426L18.2009 18.2888L15.6347 20.2925Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.6139 21.7426L15.6347 20.2925L15.8719 22.2348L15.8456 23.0521L18.6139 21.7426Z",
      fill: "#D7C1B3",
      stroke: "#D7C1B3",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.38606 21.7426L12.1544 23.0521L12.1368 22.2348L12.3566 20.2925L9.38606 21.7426Z",
      fill: "#D7C1B3",
      stroke: "#D7C1B3",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M12.1984 17.0056L9.72002 16.2762L11.4689 15.4765L12.1984 17.0056Z",
      fill: "#233447",
      stroke: "#233447",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.7928 17.0056L16.5223 15.4765L18.28 16.2762L15.7928 17.0056Z",
      fill: "#233447",
      stroke: "#233447",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.38606 21.7426L9.80791 18.1745L7.05712 18.2536L9.38606 21.7426Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.1921 18.1745L18.6139 21.7426L20.9429 18.2536L18.1921 18.1745Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M20.2837 14.2461L15.3446 14.4658L15.8016 17.0057L16.5311 15.4765L18.2888 16.2762L20.2837 14.2461Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.72002 16.2762L11.4777 15.4765L12.1984 17.0057L12.6642 14.4658L7.71626 14.2461L9.72002 16.2762Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M7.71626 14.2461L9.79033 18.2888L9.72002 16.2762L7.71626 14.2461Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.2888 16.2762L18.2009 18.2888L20.2837 14.2461L18.2888 16.2762Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M12.6642 14.4658L12.1984 17.0057L12.7784 20.0025L12.9102 16.0565L12.6642 14.4658Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.3446 14.4658L15.1073 16.0477L15.2128 20.0025L15.8016 17.0057L15.3446 14.4658Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.8016 17.0056L15.2128 20.0025L15.6347 20.2925L18.2009 18.2888L18.2888 16.2762L15.8016 17.0056Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.72002 16.2762L9.79033 18.2888L12.3566 20.2925L12.7784 20.0025L12.1984 17.0056L9.72002 16.2762Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.8456 23.0521L15.8719 22.2348L15.6522 22.0414H12.339L12.1368 22.2348L12.1544 23.0521L9.38606 21.7426L10.3528 22.5336L12.3126 23.8958H15.6786L17.6472 22.5336L18.6139 21.7426L15.8456 23.0521Z",
      fill: "#C0AD9E",
      stroke: "#C0AD9E",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.6347 20.2925L15.2128 20.0025H12.7784L12.3566 20.2925L12.1368 22.2348L12.339 22.0414H15.6522L15.8719 22.2348L15.6347 20.2925Z",
      fill: "#161616",
      stroke: "#161616",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M24.4583 10.0364L25.2053 6.45072L24.0891 3.1199L15.6347 9.39485L18.8864 12.1456L23.4827 13.4903L24.5022 12.3038L24.0628 11.9874L24.7658 11.3459L24.221 10.924L24.924 10.3879L24.4583 10.0364Z",
      fill: "#763D16",
      stroke: "#763D16",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M2.79472 6.45072L3.54174 10.0364L3.06717 10.3879L3.77024 10.924L3.23415 11.3459L3.93722 11.9874L3.4978 12.3038L4.50847 13.4903L9.10483 12.1456L12.3566 9.39485L3.90207 3.1199L2.79472 6.45072Z",
      fill: "#763D16",
      stroke: "#763D16",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M23.4827 13.4903L18.8864 12.1456L20.2837 14.2461L18.2009 18.2888L20.9429 18.2536H25.0295L23.4827 13.4903Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.10484 12.1456L4.50848 13.4903L2.97929 18.2536H7.05713L9.79033 18.2888L7.71626 14.2461L9.10484 12.1456Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.3446 14.4658L15.6347 9.39485L16.9705 5.7828H11.0383L12.3566 9.39485L12.6642 14.4658L12.7696 16.0653L12.7784 20.0025H15.2128L15.2304 16.0653L15.3446 14.4658Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  })
};

const WalletConnectIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("rect", {
      width: "28",
      height: "28",
      fill: "#3B99FC"
    }), /*#__PURE__*/jsx("path", {
      d: "M8.38969 10.3739C11.4882 7.27538 16.5118 7.27538 19.6103 10.3739L19.9832 10.7468C20.1382 10.9017 20.1382 11.1529 19.9832 11.3078L18.7076 12.5835C18.6301 12.6609 18.5045 12.6609 18.4271 12.5835L17.9139 12.0703C15.7523 9.9087 12.2477 9.9087 10.0861 12.0703L9.53655 12.6198C9.45909 12.6973 9.3335 12.6973 9.25604 12.6198L7.98039 11.3442C7.82547 11.1893 7.82547 10.9381 7.98039 10.7832L8.38969 10.3739ZM22.2485 13.012L23.3838 14.1474C23.5387 14.3023 23.5387 14.5535 23.3838 14.7084L18.2645 19.8277C18.1096 19.9827 17.8584 19.9827 17.7035 19.8277C17.7035 19.8277 17.7035 19.8277 17.7035 19.8277L14.0702 16.1944C14.0314 16.1557 13.9686 16.1557 13.9299 16.1944C13.9299 16.1944 13.9299 16.1944 13.9299 16.1944L10.2966 19.8277C10.1417 19.9827 9.89053 19.9827 9.73561 19.8278C9.7356 19.8278 9.7356 19.8277 9.7356 19.8277L4.61619 14.7083C4.46127 14.5534 4.46127 14.3022 4.61619 14.1473L5.75152 13.012C5.90645 12.857 6.15763 12.857 6.31255 13.012L9.94595 16.6454C9.98468 16.6841 10.0475 16.6841 10.0862 16.6454C10.0862 16.6454 10.0862 16.6454 10.0862 16.6454L13.7194 13.012C13.8743 12.857 14.1255 12.857 14.2805 13.012C14.2805 13.012 14.2805 13.012 14.2805 13.012L17.9139 16.6454C17.9526 16.6841 18.0154 16.6841 18.0541 16.6454L21.6874 13.012C21.8424 12.8571 22.0936 12.8571 22.2485 13.012Z",
      fill: "white"
    })]
  })
};

var _templateObject$3;
const StyledSvg = styled.svg(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n  border-radius: 0.25em;\n  flex-shrink: 0;\n  ", "\n"])), props => props.boxSize ? "width: ".concat(props.boxSize, ";\n    height: ").concat(props.boxSize, ";") : "");
const iconMap = {
  metamask: MetamaskIcon,
  walletConnect: WalletConnectIcon,
  coinbaseWallet: CoinbaseWalletIcon,
  ...chainLogos
};
const Icon = _ref => {
  let {
    name,
    ...props
  } = _ref;
  const icon = iconMap[name];
  return /*#__PURE__*/jsx(StyledSvg, { ...icon.svgProps,
    ...props,
    children: icon.paths
  });
};

var _templateObject$2;
const MenuItemBase = styled.li(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["\n  display: flex;\n  padding: 0.75em 1em;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 1em;\n\n  ", "\n\n  > svg {\n    flex-shrink: 0;\n  }\n"])), props => props.isSelectable ? "&:hover,\n  &[data-focus] {\n    cursor: pointer;\n    background: ".concat(color(props.theme.colors.text).alpha(0.15).hexa(), ";\n  }") : "");
const MenuItem = _ref => {
  let {
    children,
    leftElement,
    rightElement,
    isSelectable = true,
    onClick,
    ...restProps
  } = _ref;
  return /*#__PURE__*/jsxs(MenuItemBase, { ...restProps,
    onClick: isSelectable ? onClick : undefined,
    isSelectable: isSelectable,
    children: [leftElement, children, rightElement]
  });
};

var _templateObject$1;
const Menu = styled.ul(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n  padding: 0;\n  margin: 0;\n  background: ", ";\n  color: ", ";\n  outline-color: ", ";\n  outline-style: solid;\n  outline-offset: 0px;\n  list-style: none;\n  border-radius: 0.5em;\n  overflow: hidden;\n"])), props => props.theme.colors.background, props => props.theme.colors.text, props => props.theme.colors.accent);

const lightModeTheme = {
  colors: {
    accent: "#fff",
    background: "#fff",
    text: "#000"
  }
};
const darkModeTheme = {
  colors: {
    accent: "#000",
    background: "#000",
    text: "#fff"
  }
};
const fontFamily = "SFRounded, ui-rounded, \"SF Pro Rounded\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica,\nArial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"";

const ThemeProvider = _ref => {
  let {
    colorMode,
    accentColor,
    children
  } = _ref;
  const theme = useMemo(() => {
    const t = colorMode === "light" ? lightModeTheme : darkModeTheme;
    return { ...t,
      colors: { ...t.colors,
        accent: accentColor || t.colors.accent
      }
    };
  }, [accentColor, colorMode]);
  return /*#__PURE__*/jsx(ThemeProvider$1, {
    theme: theme,
    children: /*#__PURE__*/jsx("span", {
      style: {
        fontFamily
      },
      children: children
    })
  });
};

var _templateObject;
const Select = styled.select(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  margin: -0.25em 0;\n  background: ", ";\n  color: ", ";\n  border: 1px solid\n    ", ";\n  border-radius: 0.25em;\n  padding: 0.25em;\n  width: 100%;\n  flex-shrink: 1;\n  font-size: 1em;\n  &:hover {\n    cursor: pointer;\n  }\n  &:focus {\n    outline: 2px solid ", ";\n  }\n  &:disabled {\n    cursor: not-allowed;\n  }\n"])), props => color(props.theme.colors.background).alpha(0.85).hexa(), props => props.theme.colors.text, props => color(props.theme.colors.text).alpha(0.25).hexa(), props => props.theme.colors.accent);

const SupportedNetworkSelect = _ref => {
  let {
    disabledChainIds,
    ...selectProps
  } = _ref;
  const deprecatedNetworks = useMemo(() => {
    return SUPPORTED_CHAIN_IDS.map(supportedChain => {
      return getChainFromChainId(supportedChain);
    }).filter(n => n.id === ChainId.Rinkeby);
  }, []);
  const testnets = useMemo(() => {
    return SUPPORTED_CHAIN_IDS.map(supportedChain => {
      return getChainFromChainId(supportedChain);
    }).filter(n => n.testnet && n.id !== ChainId.Rinkeby);
  }, []);
  const mainnets = useMemo(() => {
    return SUPPORTED_CHAIN_IDS.map(supportedChain => {
      return getChainFromChainId(supportedChain);
    }).filter(n => !n.testnet);
  }, []);
  return /*#__PURE__*/jsxs(Select, { ...selectProps,
    children: [/*#__PURE__*/jsx("option", {
      disabled: true,
      value: -1,
      children: "Select Network"
    }), /*#__PURE__*/jsx("optgroup", {
      label: "Mainnets",
      children: mainnets.map(mn => {
        var _mn$nativeCurrency;

        return /*#__PURE__*/jsxs("option", {
          value: mn.id,
          disabled: disabledChainIds === null || disabledChainIds === void 0 ? void 0 : disabledChainIds.includes(mn.id),
          children: [mn.name, " (", (_mn$nativeCurrency = mn.nativeCurrency) === null || _mn$nativeCurrency === void 0 ? void 0 : _mn$nativeCurrency.symbol, ")"]
        }, mn.id);
      })
    }), /*#__PURE__*/jsx("optgroup", {
      label: "Testnets",
      children: testnets.map(tn => {
        var _tn$nativeCurrency;

        return /*#__PURE__*/jsxs("option", {
          value: tn.id,
          disabled: disabledChainIds === null || disabledChainIds === void 0 ? void 0 : disabledChainIds.includes(tn.id),
          children: [tn.name, " (", (_tn$nativeCurrency = tn.nativeCurrency) === null || _tn$nativeCurrency === void 0 ? void 0 : _tn$nativeCurrency.symbol, ")"]
        }, tn.id);
      })
    }), /*#__PURE__*/jsx("optgroup", {
      label: "Deprecated",
      children: deprecatedNetworks.map(tn => {
        var _tn$nativeCurrency2;

        return /*#__PURE__*/jsxs("option", {
          value: tn.id,
          disabled: disabledChainIds === null || disabledChainIds === void 0 ? void 0 : disabledChainIds.includes(tn.id),
          children: [tn.name, " (", (_tn$nativeCurrency2 = tn.nativeCurrency) === null || _tn$nativeCurrency2 === void 0 ? void 0 : _tn$nativeCurrency2.symbol, ")"]
        }, tn.id);
      })
    })]
  });
};

const SUPPORTED_CONNECTORS = ["injected", "walletConnect", "coinbasewallet"];

function getIconForConnector(connector) {
  if (connector.name.toLowerCase().includes("coinbase")) {
    return /*#__PURE__*/jsx(Icon, {
      boxSize: "1.5em",
      name: "coinbaseWallet"
    });
  }

  if (connector.name.toLocaleLowerCase().includes("metamask")) {
    return /*#__PURE__*/jsx(Icon, {
      boxSize: "1.5em",
      name: "metamask"
    });
  }

  const id = connector.id;

  switch (id) {
    case "injected":
      return /*#__PURE__*/jsx(Icon, {
        boxSize: "1.5em",
        name: "metamask"
      });

    case "walletConnect":
      return /*#__PURE__*/jsx(Icon, {
        boxSize: "1.5em",
        name: "walletConnect"
      });

    case "coinbasewallet":
      return /*#__PURE__*/jsx(Icon, {
        boxSize: "1.5em",
        name: "coinbaseWallet"
      });

    default:
      throw new Error("unsupported connector");
  }
}

let connecting = false;
let switchingNetwork = false;
let authing = false;
let switchingWallet = false;
const chainIdToCurrencyMap = {
  [ChainId.Mainnet]: "ethereum",
  [ChainId.Goerli]: "ethereum",
  [ChainId.Rinkeby]: "ethereum",
  [ChainId.Arbitrum]: "arbitrum",
  [ChainId.ArbitrumTestnet]: "arbitrum",
  [ChainId.Avalanche]: "avalanche",
  [ChainId.AvalancheFujiTestnet]: "avalanche",
  [ChainId.Fantom]: "fantom",
  [ChainId.FantomTestnet]: "fantom",
  [ChainId.Optimism]: "optimism",
  [ChainId.OptimismTestnet]: "optimism",
  [ChainId.Polygon]: "polygon",
  [ChainId.Mumbai]: "polygon",
  [ChainId.BinanceSmartChainMainnet]: "binance",
  [ChainId.BinanceSmartChainTestnet]: "binance"
};
/**
 * A component that allows the user to connect their wallet.
 *
 * The button has to be wrapped in a `ThirdwebProvider` in order to function.
 *
 * @example
 * ```javascript
 * import { ConnectWallet } from '@thirdweb-dev/react';
 *
 * const App = () => {
 *  return (
 *   <div>
 *     <ConnectWallet />
 *   </div>
 * )
 * }
 * ```
 *
 *
 * @beta
 */

const ConnectWallet = _ref => {
  var _balanceQuery$data, _balanceQuery$data2;

  let {
    auth,
    ...themeProps
  } = _ref;
  const id = useId();
  const isMounted = useIsMounted();
  const address = useAddress();
  const mountedAddress = useMemo(() => {
    return isMounted ? address : null;
  }, [address, isMounted]);
  const [state, send] = useMachine(menu.machine({
    id,
    closeOnSelect: true,
    positioning: {
      sameWidth: true
    }
  }));
  const api = menu.connect(state, send, normalizeProps);
  const [{
    data: {
      connectors,
      connector
    }
  }, connect] = useConnect();
  const disconnect = useDisconnect({
    reconnectAfterGnosis: false
  });
  const supportedConnectors = connectors.filter(c => SUPPORTED_CONNECTORS.includes(c.id));
  const [network, switchNetwork] = useNetwork();
  const chainId = useChainId();
  const connectWithMetamask = useMetamask();
  const balanceQuery = useBalance();
  const {
    onCopy,
    hasCopied
  } = useClipboard(mountedAddress || "");
  const authConfig = useThirdwebAuthConfig();
  const {
    user,
    isLoading,
    login,
    logout
  } = useAuth(auth === null || auth === void 0 ? void 0 : auth.loginConfig);
  const requiresSignIn = auth !== null && auth !== void 0 && auth.loginOptional ? false : !!(authConfig !== null && authConfig !== void 0 && authConfig.authUrl) && !!mountedAddress && !(user !== null && user !== void 0 && user.address);
  return /*#__PURE__*/jsx(ThemeProvider, { ...themeProps,
    children: /*#__PURE__*/jsxs("div", {
      style: {
        position: "relative"
      },
      children: [/*#__PURE__*/jsx(Button, {
        style: {
          height: "50px",
          minWidth: "200px"
        },
        onClick: async e => {
          if (requiresSignIn) {
            e.preventDefault();
            e.stopPropagation();
            authing = true;

            try {
              await login(auth === null || auth === void 0 ? void 0 : auth.loginOptions);
            } catch (err) {
              console.error("failed to log in", err);
            }

            authing = false;
          }
        },
        ...(requiresSignIn ? {} : api.triggerProps),
        leftElement: requiresSignIn ? isLoading ? /*#__PURE__*/jsx(Spinner, {}) : /*#__PURE__*/jsx(FiLock, {}) : mountedAddress && chainId && chainId in chainIdToCurrencyMap ? /*#__PURE__*/jsx(Icon, {
          boxSize: "1.5em",
          name: chainIdToCurrencyMap[chainId]
        }) : undefined,
        rightElement: requiresSignIn ? undefined : /*#__PURE__*/jsxs(Fragment, {
          children: [connector && getIconForConnector(connector), /*#__PURE__*/jsx(FiChevronDown, {
            style: {
              transition: "transform 150ms ease",
              transform: "rotate(".concat(api.isOpen ? "-180deg" : "0deg", ")")
            }
          })]
        }),
        children: mountedAddress ? requiresSignIn ? /*#__PURE__*/jsx("span", {
          style: {
            whiteSpace: "nowrap"
          },
          children: "Sign in"
        }) : /*#__PURE__*/jsxs("span", {
          style: {
            display: "flex",
            flexDirection: "column",
            fontWeight: 400,
            alignItems: "flex-start",
            fontSize: "0.8em"
          },
          children: [/*#__PURE__*/jsx("span", {
            style: {
              whiteSpace: "nowrap",
              fontWeight: 500
            },
            children: balanceQuery.isLoading ? "Loading..." : /*#__PURE__*/jsxs(Fragment, {
              children: [(_balanceQuery$data = balanceQuery.data) === null || _balanceQuery$data === void 0 ? void 0 : _balanceQuery$data.displayValue.slice(0, 5), " ", (_balanceQuery$data2 = balanceQuery.data) === null || _balanceQuery$data2 === void 0 ? void 0 : _balanceQuery$data2.symbol]
            })
          }), /*#__PURE__*/jsx("span", {
            style: {
              fontSize: "0.9em"
            },
            children: shortenIfAddress(mountedAddress)
          })]
        }) : /*#__PURE__*/jsx("span", {
          style: {
            whiteSpace: "nowrap"
          },
          children: "Connect Wallet"
        })
      }), /*#__PURE__*/jsx(Portal, {
        children: /*#__PURE__*/jsx(Box, { ...api.positionerProps,
          style: {
            zIndex: 9999,
            fontFamily
          },
          children: /*#__PURE__*/jsx(Menu, { ...api.contentProps,
            children: !api.isOpen ? null : mountedAddress ? /*#__PURE__*/jsxs(Fragment, {
              children: [authConfig !== null && authConfig !== void 0 && authConfig.authUrl && !(user !== null && user !== void 0 && user.address) && !requiresSignIn ? /*#__PURE__*/jsx(MenuItem, { ...api.getItemProps({
                  id: "auth",
                  closeOnSelect: false
                }),
                leftElement: isLoading ? /*#__PURE__*/jsx(Spinner, {}) : /*#__PURE__*/jsx(FiLock, {}),
                onClick: async () => {
                  if (isLoading || authing || user !== null && user !== void 0 && user.address) {
                    return;
                  }

                  authing = true;

                  try {
                    await login(auth === null || auth === void 0 ? void 0 : auth.loginOptions);
                  } catch (err) {
                    console.error("failed to log in", err);
                  }

                  authing = false;
                },
                children: "Sign in"
              }) : null, /*#__PURE__*/jsx(MenuItem, { ...api.getItemProps({
                  id: "copy",
                  closeOnSelect: false
                }),
                leftElement: hasCopied ? /*#__PURE__*/jsx(FiCheck, {
                  width: "1em",
                  height: "1em",
                  color: "#57ab5a"
                }) : /*#__PURE__*/jsx(FiCopy, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: () => {
                  onCopy();
                },
                children: "Copy address"
              }), /*#__PURE__*/jsx(MenuItem, { ...api.getItemProps({
                  id: "switch-network",
                  closeOnSelect: false,
                  disabled: !switchNetwork
                }),
                isSelectable: false,
                leftElement: network.loading ? /*#__PURE__*/jsx(Spinner, {}) : network.error ? /*#__PURE__*/jsx(FiWifi, {
                  color: "#e5534b",
                  width: "1em",
                  height: "1em"
                }) : /*#__PURE__*/jsx(FiWifi, {
                  width: "1em",
                  height: "1em"
                }),
                children: /*#__PURE__*/jsx(SupportedNetworkSelect, {
                  value: chainId,
                  disabled: !switchNetwork,
                  onChange: async e => {
                    if (!switchingNetwork && switchNetwork) {
                      switchingNetwork = true;
                      const number = parseInt(e.target.value);

                      try {
                        await switchNetwork(number);
                      } catch (err) {
                        console.error("failed to switch network", err);
                      } finally {
                        switchingNetwork = false;
                      }
                    }
                  }
                })
              }), connector && connector.name === "MetaMask" && connector.id === "injected" ? /*#__PURE__*/jsx(MenuItem, { ...api.getItemProps({
                  id: "switch-wallet"
                }),
                leftElement: /*#__PURE__*/jsx(FiShuffle, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: async () => {
                  if (switchingWallet) {
                    return;
                  }

                  switchingWallet = true;

                  try {
                    await connector.getProvider().request({
                      method: "wallet_requestPermissions",
                      params: [{
                        eth_accounts: {}
                      }]
                    });
                    api.close();
                  } catch (err) {
                    console.error("failed to switch wallets", err);
                  }

                  switchingWallet = false;
                },
                children: "Switch Account"
              }) : null, /*#__PURE__*/jsx(MenuItem, { ...api.getItemProps({
                  id: "disconnect"
                }),
                leftElement: /*#__PURE__*/jsx(FiXCircle, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: () => {
                  disconnect();

                  if (authConfig !== null && authConfig !== void 0 && authConfig.authUrl) {
                    logout();
                  }

                  api.close();
                },
                children: "Disconnect"
              })]
            }) : /*#__PURE__*/jsxs(Fragment, {
              children: [/*#__PURE__*/jsx(MenuItem, { ...api.getItemProps({
                  id: "metamask"
                }),
                onClick: async () => {
                  if (!connecting) {
                    connecting = true;
                    await connectWithMetamask();
                    connecting = false;
                    api.close();
                  }
                },
                leftElement: /*#__PURE__*/jsx(Icon, {
                  boxSize: "1.5em",
                  name: "metamask"
                }),
                children: "MetaMask"
              }), supportedConnectors.filter(c => c.name !== "MetaMask").sort((a, b) => a.name.localeCompare(b.name)).map(c => {
                if (!c.ready) {
                  return null;
                }

                return /*#__PURE__*/jsx(MenuItem, { ...api.getItemProps({
                    id: c.id
                  }),
                  onClick: async () => {
                    if (!connecting) {
                      connecting = true;
                      await connect(c);
                      connecting = false;
                      api.close();
                    }
                  },
                  leftElement: getIconForConnector(c),
                  children: c.name
                }, c.id);
              })]
            })
          })
        })
      })]
    })
  });
};

/**
 * A component that allows the user to call an on-chain function on a contract.
 *
 * The button has to be wrapped in a `ThirdwebProvider` in order to function.
 *
 * @example
 * ```javascript
 * import { Web3Button } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *  return (
 *   <div>
 *     <Web3Button contractAddress="0x..." action={(contract) => contract.erc721.transfer("0x...", 1)} />
 *   </div>
 * )
 * }
 * ```
 *
 *
 * @beta
 */
const Web3Button = _ref => {
  let {
    contractAddress,
    overrides,
    onSuccess,
    onError,
    onSubmit,
    isDisabled,
    children,
    action,
    ...themeProps
  } = _ref;
  const address = useAddress();
  const walletChainId = useChainId();
  const sdkChainId = useActiveChainId();
  const [, switchNetwork] = useNetwork();
  const queryClient = useQueryClient();
  const switchToChainId = useMemo(() => {
    if (sdkChainId && walletChainId && sdkChainId !== walletChainId) {
      return sdkChainId;
    }

    return null;
  }, [sdkChainId, walletChainId]);
  const contractQuery = useContract(contractAddress);
  const mutation = useMutation(async () => {
    if (switchToChainId) {
      if (switchNetwork) {
        await switchNetwork(switchToChainId);
        await new Promise(resolve => setTimeout(resolve, 500));
      } else {
        throw new Error("need to switch chain but connected wallet does not support switching");
      }
    }

    invariant(contractQuery.contract, "contract is not ready yet");

    if (onSubmit) {
      onSubmit();
    }

    return await action(contractQuery.contract);
  }, {
    onSuccess: res => {
      if (onSuccess) {
        onSuccess(res);
      }
    },
    onError: err => {
      if (onError) {
        onError(err);
      }
    },
    onSettled: () => queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), sdkChainId))
  });

  if (!address) {
    return /*#__PURE__*/jsx(ConnectWallet, { ...themeProps
    });
  }

  return /*#__PURE__*/jsx(ThemeProvider, { ...themeProps,
    children: /*#__PURE__*/jsx(Button, {
      style: {
        height: "50px"
      },
      isLoading: mutation.isLoading || !contractQuery.contract,
      onClick: () => mutation.mutate(),
      isDisabled: isDisabled,
      children: children
    })
  });
};

export { ConnectWallet, MediaRenderer, ThirdwebNftMedia, ThirdwebProvider, ThirdwebSDKProvider, Web3Button, useActiveChainId, useActiveClaimCondition, useActiveListings, useAddress, useAirdropNFT, useAllContractEvents, useAllRoleMembers, useAuctionWinner, useAuth, useBalance, useBatchesToReveal, useBidBuffer, useBuiltinContract, useBurnNFT, useBurnToken, useBuyNow, useChainId, useClaimConditions, useClaimIneligibilityReasons, useClaimNFT, useClaimToken, useClaimedNFTSupply, useClaimedNFTs, useCoinbaseWallet, useConnect, useContract, useContractAbi, useContractCall, useContractCompilerMetadata, useContractData, useContractEvents, useContractFunctions, useContractMetadata, useContractType, useCreateAuctionListing, useCreateDirectListing, useDelayedRevealLazyMint, useDesiredChainId, useDisconnect, useEdition, useEditionDrop, useGnosis, useGrantRole, useIsAddressRole, useLazyMint, useListing, useListings, useLogin, useLogout, useMagic, useMakeBid, useMarketplace, useMetadata, useMetamask, useMintNFT, useMintNFTSupply, useMintToken, useMultiwrap, useNFT, useNFTBalance, useNFTCollection, useNFTDrop, useNFTs, useNetwork, useNetworkMismatch, useOwnedNFTs, usePack, usePlatformFees, usePrimarySaleRecipient, useReadonlySDK, useResetClaimConditions, useResolvedMediaType, useRevealLazyMint, useRevokeRole, useRoleMembers, useRoyaltySettings, useSDK, useSetAllRoleMembers, useSetClaimConditions, useSignatureDrop, useSigner, useSplit, useToken, useTokenBalance, useTokenDrop, useTokenSupply, useTotalCirculatingSupply, useTotalCount, useTransferBatchToken, useTransferNFT, useTransferToken, useUnclaimedNFTSupply, useUnclaimedNFTs, useUpdateMetadata, useUpdatePlatformFees, useUpdatePrimarySaleRecipient, useUpdateRoyaltySettings, useUser, useVote, useWalletConnect, useWalletLink, useWinningBid };
